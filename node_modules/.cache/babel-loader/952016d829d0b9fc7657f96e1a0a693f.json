{"ast":null,"code":"/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FixedDataTableNew.react\n * @typechecks\n * @noflow\n */\n\n/*eslint no-bitwise:1*/\n'use strict';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar React = require('./React');\n\nvar createReactClass = require('create-react-class');\n\nvar ReactComponentWithPureRenderMixin = require('./ReactComponentWithPureRenderMixin');\n\nvar ReactWheelHandler = require('./ReactWheelHandler');\n\nvar Scrollbar = require('./Scrollbar.react');\n\nvar FixedDataTableBufferedRows = require('./FixedDataTableBufferedRows.react');\n\nvar FixedDataTableColumnResizeHandle = require('./FixedDataTableColumnResizeHandle.react');\n\nvar FixedDataTableRow = require('./FixedDataTableRow.react');\n\nvar FixedDataTableScrollHelper = require('./FixedDataTableScrollHelper');\n\nvar FixedDataTableWidthHelper = require('./FixedDataTableWidthHelper');\n\nvar cx = require('./cx');\n\nvar debounceCore = require('./debounceCore');\n\nvar emptyFunction = require('./emptyFunction');\n\nvar invariant = require('./invariant');\n\nvar joinClasses = require('./joinClasses');\n\nvar shallowEqual = require('./shallowEqual');\n\nvar translateDOMPositionXY = require('./translateDOMPositionXY');\n\nvar PropTypes = require('prop-types');\n\nvar ReactChildren = React.Children;\nvar EMPTY_OBJECT = {};\nvar BORDER_HEIGHT = 1;\nvar HEADER = 'header';\nvar FOOTER = 'footer';\nvar CELL = 'cell';\n/**\n * Data grid component with fixed or scrollable header and columns.\n *\n * The layout of the data table is as follows:\n *\n * ```\n * +---------------------------------------------------+\n * | Fixed Column Group    | Scrollable Column Group   |\n * | Header                | Header                    |\n * |                       |                           |\n * +---------------------------------------------------+\n * |                       |                           |\n * | Fixed Header Columns  | Scrollable Header Columns |\n * |                       |                           |\n * +-----------------------+---------------------------+\n * |                       |                           |\n * | Fixed Body Columns    | Scrollable Body Columns   |\n * |                       |                           |\n * +-----------------------+---------------------------+\n * |                       |                           |\n * | Fixed Footer Columns  | Scrollable Footer Columns |\n * |                       |                           |\n * +-----------------------+---------------------------+\n * ```\n *\n * - Fixed Column Group Header: These are the headers for a group\n *   of columns if included in the table that do not scroll\n *   vertically or horizontally.\n *\n * - Scrollable Column Group Header: The header for a group of columns\n *   that do not move while scrolling vertically, but move horizontally\n *   with the horizontal scrolling.\n *\n * - Fixed Header Columns: The header columns that do not move while scrolling\n *   vertically or horizontally.\n *\n * - Scrollable Header Columns: The header columns that do not move\n *   while scrolling vertically, but move horizontally with the horizontal\n *   scrolling.\n *\n * - Fixed Body Columns: The body columns that do not move while scrolling\n *   horizontally, but move vertically with the vertical scrolling.\n *\n * - Scrollable Body Columns: The body columns that move while scrolling\n *   vertically or horizontally.\n */\n\nvar FixedDataTable = createReactClass({\n  propTypes: {\n    /**\n     * Pixel width of table. If all columns do not fit,\n     * a horizontal scrollbar will appear.\n     */\n    width: PropTypes.number.isRequired,\n\n    /**\n     * Pixel height of table. If all rows do not fit,\n     * a vertical scrollbar will appear.\n     *\n     * Either `height` or `maxHeight` must be specified.\n     */\n    height: PropTypes.number,\n\n    /**\n     * Maximum pixel height of table. If all rows do not fit,\n     * a vertical scrollbar will appear.\n     *\n     * Either `height` or `maxHeight` must be specified.\n     */\n    maxHeight: PropTypes.number,\n\n    /**\n     * Pixel height of table's owner, this is used in a managed scrolling\n     * situation when you want to slide the table up from below the fold\n     * without having to constantly update the height on every scroll tick.\n     * Instead, vary this property on scroll. By using `ownerHeight`, we\n     * over-render the table while making sure the footer and horizontal\n     * scrollbar of the table are visible when the current space for the table\n     * in view is smaller than the final, over-flowing height of table. It\n     * allows us to avoid resizing and reflowing table when it is moving in the\n     * view.\n     *\n     * This is used if `ownerHeight < height` (or `maxHeight`).\n     */\n    ownerHeight: PropTypes.number,\n    overflowX: PropTypes.oneOf(['hidden', 'auto']),\n    overflowY: PropTypes.oneOf(['hidden', 'auto']),\n\n    /**\n     * Number of rows in the table.\n     */\n    rowsCount: PropTypes.number.isRequired,\n\n    /**\n     * Pixel height of rows unless `rowHeightGetter` is specified and returns\n     * different value.\n     */\n    rowHeight: PropTypes.number.isRequired,\n\n    /**\n     * If specified, `rowHeightGetter(index)` is called for each row and the\n     * returned value overrides `rowHeight` for particular row.\n     */\n    rowHeightGetter: PropTypes.func,\n\n    /**\n     * To get any additional CSS classes that should be added to a row,\n     * `rowClassNameGetter(index)` is called.\n     */\n    rowClassNameGetter: PropTypes.func,\n\n    /**\n     * Pixel height of the column group header.\n     */\n    groupHeaderHeight: PropTypes.number,\n\n    /**\n     * Pixel height of header.\n     */\n    headerHeight: PropTypes.number.isRequired,\n\n    /**\n     * Pixel height of footer.\n     */\n    footerHeight: PropTypes.number,\n\n    /**\n     * Value of horizontal scroll.\n     */\n    scrollLeft: PropTypes.number,\n\n    /**\n     * Index of column to scroll to.\n     */\n    scrollToColumn: PropTypes.number,\n\n    /**\n     * Value of vertical scroll.\n     */\n    scrollTop: PropTypes.number,\n\n    /**\n     * Index of row to scroll to.\n     */\n    scrollToRow: PropTypes.number,\n\n    /**\n     * Callback that is called when scrolling starts with current horizontal\n     * and vertical scroll values.\n     */\n    onScrollStart: PropTypes.func,\n\n    /**\n     * Callback that is called when scrolling ends or stops with new horizontal\n     * and vertical scroll values.\n     */\n    onScrollEnd: PropTypes.func,\n\n    /**\n     * Callback that is called when `rowHeightGetter` returns a different height\n     * for a row than the `rowHeight` prop. This is necessary because initially\n     * table estimates heights of some parts of the content.\n     */\n    onContentHeightChange: PropTypes.func,\n\n    /**\n     * Callback that is called when a row is clicked.\n     */\n    onRowClick: PropTypes.func,\n\n    /**\n     * Callback that is called when a row is double clicked.\n     */\n    onRowDoubleClick: PropTypes.func,\n\n    /**\n     * Callback that is called when a mouse-down event happens on a row.\n     */\n    onRowMouseDown: PropTypes.func,\n\n    /**\n     * Callback that is called when a mouse-enter event happens on a row.\n     */\n    onRowMouseEnter: PropTypes.func,\n\n    /**\n     * Callback that is called when a mouse-leave event happens on a row.\n     */\n    onRowMouseLeave: PropTypes.func,\n\n    /**\n     * Callback that is called when resizer has been released\n     * and column needs to be updated.\n     *\n     * Required if the isResizable property is true on any column.\n     *\n     * ```\n     * function(\n     *   newColumnWidth: number,\n     *   columnKey: string,\n     * )\n     * ```\n     */\n    onColumnResizeEndCallback: PropTypes.func,\n\n    /**\n     * Whether a column is currently being resized.\n     */\n    isColumnResizing: PropTypes.bool\n  },\n  getDefaultProps: function getDefaultProps()\n  /*object*/\n  {\n    return {\n      footerHeight: 0,\n      groupHeaderHeight: 0,\n      headerHeight: 0,\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n  },\n  getInitialState: function getInitialState()\n  /*object*/\n  {\n    var props = this.props;\n    var viewportHeight = (props.height === undefined ? props.maxHeight : props.height) - (props.headerHeight || 0) - (props.footerHeight || 0) - (props.groupHeaderHeight || 0);\n    this._scrollHelper = new FixedDataTableScrollHelper(props.rowsCount, props.rowHeight, viewportHeight, props.rowHeightGetter);\n\n    if (props.scrollTop) {\n      this._scrollHelper.scrollTo(props.scrollTop);\n    }\n\n    this._didScrollStop = debounceCore(this._didScrollStop, 200, this);\n    return this._calculateState(this.props);\n  },\n  componentWillMount: function componentWillMount() {\n    var scrollToRow = this.props.scrollToRow;\n\n    if (scrollToRow !== undefined && scrollToRow !== null) {\n      this._rowToScrollTo = scrollToRow;\n    }\n\n    var scrollToColumn = this.props.scrollToColumn;\n\n    if (scrollToColumn !== undefined && scrollToColumn !== null) {\n      this._columnToScrollTo = scrollToColumn;\n    }\n\n    this._wheelHandler = new ReactWheelHandler(this._onWheel, this._shouldHandleWheelX, this._shouldHandleWheelY);\n  },\n  _shouldHandleWheelX: function _shouldHandleWheelX(\n  /*number*/\n  delta)\n  /*boolean*/\n  {\n    if (this.props.overflowX === 'hidden') {\n      return false;\n    }\n\n    delta = Math.round(delta);\n\n    if (delta === 0) {\n      return false;\n    }\n\n    return delta < 0 && this.state.scrollX > 0 || delta >= 0 && this.state.scrollX < this.state.maxScrollX;\n  },\n  _shouldHandleWheelY: function _shouldHandleWheelY(\n  /*number*/\n  delta)\n  /*boolean*/\n  {\n    if (this.props.overflowY === 'hidden' || delta === 0) {\n      return false;\n    }\n\n    delta = Math.round(delta);\n\n    if (delta === 0) {\n      return false;\n    }\n\n    return delta < 0 && this.state.scrollY > 0 || delta >= 0 && this.state.scrollY < this.state.maxScrollY;\n  },\n  _reportContentHeight: function _reportContentHeight() {\n    var scrollContentHeight = this.state.scrollContentHeight;\n    var reservedHeight = this.state.reservedHeight;\n    var requiredHeight = scrollContentHeight + reservedHeight;\n    var contentHeight;\n    var useMaxHeight = this.props.height === undefined;\n\n    if (useMaxHeight && this.props.maxHeight > requiredHeight) {\n      contentHeight = requiredHeight;\n    } else if (this.state.height > requiredHeight && this.props.ownerHeight) {\n      contentHeight = Math.max(requiredHeight, this.props.ownerHeight);\n    } else {\n      contentHeight = this.state.height + this.state.maxScrollY;\n    }\n\n    if (contentHeight !== this._contentHeight && this.props.onContentHeightChange) {\n      this.props.onContentHeightChange(contentHeight);\n    }\n\n    this._contentHeight = contentHeight;\n  },\n  componentDidMount: function componentDidMount() {\n    this._reportContentHeight();\n  },\n  componentWillReceiveProps: function componentWillReceiveProps(\n  /*object*/\n  nextProps) {\n    var scrollToRow = nextProps.scrollToRow;\n\n    if (scrollToRow !== undefined && scrollToRow !== null) {\n      this._rowToScrollTo = scrollToRow;\n    }\n\n    var scrollToColumn = nextProps.scrollToColumn;\n\n    if (scrollToColumn !== undefined && scrollToColumn !== null) {\n      this._columnToScrollTo = scrollToColumn;\n    }\n\n    var newOverflowX = nextProps.overflowX;\n    var newOverflowY = nextProps.overflowY;\n\n    if (newOverflowX !== this.props.overflowX || newOverflowY !== this.props.overflowY) {\n      this._wheelHandler = new ReactWheelHandler(this._onWheel, newOverflowX !== 'hidden', // Should handle horizontal scroll\n      newOverflowY !== 'hidden' // Should handle vertical scroll\n      );\n    } // In the case of controlled scrolling, notify.\n\n\n    if (this.props.ownerHeight !== nextProps.ownerHeight || this.props.scrollTop !== nextProps.scrollTop) {\n      this._didScrollStart();\n    }\n\n    this._didScrollStop();\n\n    this.setState(this._calculateState(nextProps, this.state));\n  },\n  componentDidUpdate: function componentDidUpdate() {\n    this._reportContentHeight();\n  },\n  render: function render()\n  /*object*/\n  {\n    var state = this.state;\n    var props = this.props;\n    var groupHeader;\n\n    if (state.useGroupHeader) {\n      groupHeader = React.createElement(FixedDataTableRow, {\n        key: 'group_header',\n        isScrolling: this._isScrolling,\n        className: joinClasses(cx('fixedDataTableLayout/header'), cx('public/fixedDataTable/header')),\n        width: state.width,\n        height: state.groupHeaderHeight,\n        index: 0,\n        zIndex: 1,\n        offsetTop: 0,\n        scrollLeft: state.scrollX,\n        fixedColumns: state.groupHeaderFixedColumns,\n        scrollableColumns: state.groupHeaderScrollableColumns,\n        onColumnResize: this._onColumnResize\n      });\n    }\n\n    var maxScrollY = this.state.maxScrollY;\n    var showScrollbarX = state.maxScrollX > 0 && state.overflowX !== 'hidden';\n    var showScrollbarY = maxScrollY > 0 && state.overflowY !== 'hidden';\n    var scrollbarXHeight = showScrollbarX ? Scrollbar.SIZE : 0;\n    var scrollbarYHeight = state.height - scrollbarXHeight - 2 * BORDER_HEIGHT - state.footerHeight;\n    var headerOffsetTop = state.useGroupHeader ? state.groupHeaderHeight : 0;\n    var bodyOffsetTop = headerOffsetTop + state.headerHeight;\n    scrollbarYHeight -= bodyOffsetTop;\n    var bottomSectionOffset = 0;\n    var footOffsetTop = props.maxHeight != null ? bodyOffsetTop + state.bodyHeight : bodyOffsetTop + scrollbarYHeight;\n    var rowsContainerHeight = footOffsetTop + state.footerHeight;\n\n    if (props.ownerHeight !== undefined && props.ownerHeight < state.height) {\n      bottomSectionOffset = props.ownerHeight - state.height;\n      footOffsetTop = Math.min(footOffsetTop, props.ownerHeight - state.footerHeight - scrollbarXHeight);\n      scrollbarYHeight = Math.max(0, footOffsetTop - bodyOffsetTop);\n    }\n\n    var verticalScrollbar;\n\n    if (showScrollbarY) {\n      verticalScrollbar = React.createElement(Scrollbar, {\n        size: scrollbarYHeight,\n        contentSize: scrollbarYHeight + maxScrollY,\n        onScroll: this._onVerticalScroll,\n        verticalTop: bodyOffsetTop,\n        position: state.scrollY\n      });\n    }\n\n    var horizontalScrollbar;\n\n    if (showScrollbarX) {\n      var scrollbarXWidth = state.width;\n      horizontalScrollbar = React.createElement(HorizontalScrollbar, {\n        contentSize: scrollbarXWidth + state.maxScrollX,\n        offset: bottomSectionOffset,\n        onScroll: this._onHorizontalScroll,\n        position: state.scrollX,\n        size: scrollbarXWidth\n      });\n    }\n\n    var dragKnob = React.createElement(FixedDataTableColumnResizeHandle, {\n      height: state.height,\n      initialWidth: state.columnResizingData.width || 0,\n      minWidth: state.columnResizingData.minWidth || 0,\n      maxWidth: state.columnResizingData.maxWidth || Number.MAX_VALUE,\n      visible: !!state.isColumnResizing,\n      leftOffset: state.columnResizingData.left || 0,\n      knobHeight: state.headerHeight,\n      initialEvent: state.columnResizingData.initialEvent,\n      onColumnResizeEnd: props.onColumnResizeEndCallback,\n      columnKey: state.columnResizingData.key\n    });\n    var footer = null;\n\n    if (state.footerHeight) {\n      footer = React.createElement(FixedDataTableRow, {\n        key: 'footer',\n        isScrolling: this._isScrolling,\n        className: joinClasses(cx('fixedDataTableLayout/footer'), cx('public/fixedDataTable/footer')),\n        width: state.width,\n        height: state.footerHeight,\n        index: -1,\n        zIndex: 1,\n        offsetTop: footOffsetTop,\n        fixedColumns: state.footFixedColumns,\n        scrollableColumns: state.footScrollableColumns,\n        scrollLeft: state.scrollX\n      });\n    }\n\n    var rows = this._renderRows(bodyOffsetTop);\n\n    var header = React.createElement(FixedDataTableRow, {\n      key: 'header',\n      isScrolling: this._isScrolling,\n      className: joinClasses(cx('fixedDataTableLayout/header'), cx('public/fixedDataTable/header')),\n      width: state.width,\n      height: state.headerHeight,\n      index: -1,\n      zIndex: 1,\n      offsetTop: headerOffsetTop,\n      scrollLeft: state.scrollX,\n      fixedColumns: state.headFixedColumns,\n      scrollableColumns: state.headScrollableColumns,\n      onColumnResize: this._onColumnResize\n    });\n    var topShadow;\n    var bottomShadow;\n\n    if (state.scrollY) {\n      topShadow = React.createElement('div', {\n        className: joinClasses(cx('fixedDataTableLayout/topShadow'), cx('public/fixedDataTable/topShadow')),\n        style: {\n          top: bodyOffsetTop\n        }\n      });\n    }\n\n    if (state.ownerHeight != null && state.ownerHeight < state.height && state.scrollContentHeight + state.reservedHeight > state.ownerHeight || state.scrollY < maxScrollY) {\n      bottomShadow = React.createElement('div', {\n        className: joinClasses(cx('fixedDataTableLayout/bottomShadow'), cx('public/fixedDataTable/bottomShadow')),\n        style: {\n          top: footOffsetTop\n        }\n      });\n    }\n\n    return React.createElement('div', {\n      className: joinClasses(cx('fixedDataTableLayout/main'), cx('public/fixedDataTable/main')),\n      onWheel: this._wheelHandler.onWheel,\n      style: {\n        height: state.height,\n        width: state.width\n      }\n    }, React.createElement('div', {\n      className: cx('fixedDataTableLayout/rowsContainer'),\n      style: {\n        height: rowsContainerHeight,\n        width: state.width\n      }\n    }, dragKnob, groupHeader, header, rows, footer, topShadow, bottomShadow), verticalScrollbar, horizontalScrollbar);\n  },\n  _renderRows: function _renderRows(\n  /*number*/\n  offsetTop)\n  /*object*/\n  {\n    var state = this.state;\n    return React.createElement(FixedDataTableBufferedRows, {\n      isScrolling: this._isScrolling,\n      defaultRowHeight: state.rowHeight,\n      firstRowIndex: state.firstRowIndex,\n      firstRowOffset: state.firstRowOffset,\n      fixedColumns: state.bodyFixedColumns,\n      height: state.bodyHeight,\n      offsetTop: offsetTop,\n      onRowClick: state.onRowClick,\n      onRowDoubleClick: state.onRowDoubleClick,\n      onRowMouseDown: state.onRowMouseDown,\n      onRowMouseEnter: state.onRowMouseEnter,\n      onRowMouseLeave: state.onRowMouseLeave,\n      rowClassNameGetter: state.rowClassNameGetter,\n      rowsCount: state.rowsCount,\n      rowGetter: state.rowGetter,\n      rowHeightGetter: state.rowHeightGetter,\n      scrollLeft: state.scrollX,\n      scrollableColumns: state.bodyScrollableColumns,\n      showLastRowBorder: true,\n      width: state.width,\n      rowPositionGetter: this._scrollHelper.getRowPosition\n    });\n  },\n\n  /**\n   * This is called when a cell that is in the header of a column has its\n   * resizer knob clicked on. It displays the resizer and puts in the correct\n   * location on the table.\n   */\n  _onColumnResize: function _onColumnResize(\n  /*number*/\n  combinedWidth,\n  /*number*/\n  leftOffset,\n  /*number*/\n  cellWidth,\n  /*?number*/\n  cellMinWidth,\n  /*?number*/\n  cellMaxWidth,\n  /*number|string*/\n  columnKey,\n  /*object*/\n  event) {\n    this.setState({\n      isColumnResizing: true,\n      columnResizingData: {\n        left: leftOffset + combinedWidth - cellWidth,\n        width: cellWidth,\n        minWidth: cellMinWidth,\n        maxWidth: cellMaxWidth,\n        initialEvent: {\n          clientX: event.clientX,\n          clientY: event.clientY,\n          preventDefault: emptyFunction\n        },\n        key: columnKey\n      }\n    });\n  },\n  _areColumnSettingsIdentical: function _areColumnSettingsIdentical(oldColumns, newColumns) {\n    if (oldColumns.length !== newColumns.length) {\n      return false;\n    }\n\n    for (var index = 0; index < oldColumns.length; ++index) {\n      if (!shallowEqual(oldColumns[index].props, newColumns[index].props)) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  _populateColumnsAndColumnData: function _populateColumnsAndColumnData(columns, columnGroups, oldState) {\n    var canReuseColumnSettings = false;\n    var canReuseColumnGroupSettings = false;\n\n    if (oldState && oldState.columns) {\n      canReuseColumnSettings = this._areColumnSettingsIdentical(columns, oldState.columns);\n    }\n\n    if (oldState && oldState.columnGroups && columnGroups) {\n      canReuseColumnGroupSettings = this._areColumnSettingsIdentical(columnGroups, oldState.columnGroups);\n    }\n\n    var columnInfo = {};\n\n    if (canReuseColumnSettings) {\n      columnInfo.bodyFixedColumns = oldState.bodyFixedColumns;\n      columnInfo.bodyScrollableColumns = oldState.bodyScrollableColumns;\n      columnInfo.headFixedColumns = oldState.headFixedColumns;\n      columnInfo.headScrollableColumns = oldState.headScrollableColumns;\n      columnInfo.footFixedColumns = oldState.footFixedColumns;\n      columnInfo.footScrollableColumns = oldState.footScrollableColumns;\n    } else {\n      var bodyColumnTypes = this._splitColumnTypes(columns);\n\n      columnInfo.bodyFixedColumns = bodyColumnTypes.fixed;\n      columnInfo.bodyScrollableColumns = bodyColumnTypes.scrollable;\n\n      var headColumnTypes = this._splitColumnTypes(this._selectColumnElement(HEADER, columns));\n\n      columnInfo.headFixedColumns = headColumnTypes.fixed;\n      columnInfo.headScrollableColumns = headColumnTypes.scrollable;\n\n      var footColumnTypes = this._splitColumnTypes(this._selectColumnElement(FOOTER, columns));\n\n      columnInfo.footFixedColumns = footColumnTypes.fixed;\n      columnInfo.footScrollableColumns = footColumnTypes.scrollable;\n    }\n\n    if (canReuseColumnGroupSettings) {\n      columnInfo.groupHeaderFixedColumns = oldState.groupHeaderFixedColumns;\n      columnInfo.groupHeaderScrollableColumns = oldState.groupHeaderScrollableColumns;\n    } else {\n      if (columnGroups) {\n        var groupHeaderColumnTypes = this._splitColumnTypes(this._selectColumnElement(HEADER, columnGroups));\n\n        columnInfo.groupHeaderFixedColumns = groupHeaderColumnTypes.fixed;\n        columnInfo.groupHeaderScrollableColumns = groupHeaderColumnTypes.scrollable;\n      }\n    }\n\n    return columnInfo;\n  },\n  _calculateState: function _calculateState(\n  /*object*/\n  props,\n  /*?object*/\n  oldState)\n  /*object*/\n  {\n    invariant(props.height !== undefined || props.maxHeight !== undefined, 'You must set either a height or a maxHeight');\n    var children = [];\n    ReactChildren.forEach(props.children, function (child, index) {\n      if (child == null) {\n        return;\n      }\n\n      invariant(child.type.__TableColumnGroup__ || child.type.__TableColumn__, 'child type should be <FixedDataTableColumn /> or ' + '<FixedDataTableColumnGroup />');\n      children.push(child);\n    });\n    var useGroupHeader = false;\n\n    if (children.length && children[0].type.__TableColumnGroup__) {\n      useGroupHeader = true;\n    }\n\n    var firstRowIndex = oldState && oldState.firstRowIndex || 0;\n    var firstRowOffset = oldState && oldState.firstRowOffset || 0;\n    var scrollX, scrollY;\n\n    if (oldState && props.overflowX !== 'hidden') {\n      scrollX = oldState.scrollX;\n    } else {\n      scrollX = props.scrollLeft;\n    }\n\n    if (oldState && props.overflowY !== 'hidden') {\n      scrollY = oldState.scrollY;\n    } else {\n      scrollState = this._scrollHelper.scrollTo(props.scrollTop);\n      firstRowIndex = scrollState.index;\n      firstRowOffset = scrollState.offset;\n      scrollY = scrollState.position;\n    }\n\n    if (this._rowToScrollTo !== undefined) {\n      scrollState = this._scrollHelper.scrollRowIntoView(this._rowToScrollTo);\n      firstRowIndex = scrollState.index;\n      firstRowOffset = scrollState.offset;\n      scrollY = scrollState.position;\n      delete this._rowToScrollTo;\n    }\n\n    var groupHeaderHeight = useGroupHeader ? props.groupHeaderHeight : 0;\n\n    if (oldState && props.rowsCount !== oldState.rowsCount) {\n      // Number of rows changed, try to scroll to the row from before the\n      // change\n      var viewportHeight = (props.height === undefined ? props.maxHeight : props.height) - (props.headerHeight || 0) - (props.footerHeight || 0) - (props.groupHeaderHeight || 0);\n      this._scrollHelper = new FixedDataTableScrollHelper(props.rowsCount, props.rowHeight, viewportHeight, props.rowHeightGetter);\n\n      var scrollState = this._scrollHelper.scrollToRow(firstRowIndex, firstRowOffset);\n\n      firstRowIndex = scrollState.index;\n      firstRowOffset = scrollState.offset;\n      scrollY = scrollState.position;\n    } else if (oldState && props.rowHeightGetter !== oldState.rowHeightGetter) {\n      this._scrollHelper.setRowHeightGetter(props.rowHeightGetter);\n    }\n\n    var columnResizingData;\n\n    if (props.isColumnResizing) {\n      columnResizingData = oldState && oldState.columnResizingData;\n    } else {\n      columnResizingData = EMPTY_OBJECT;\n    }\n\n    var columns;\n    var columnGroups;\n\n    if (useGroupHeader) {\n      var columnGroupSettings = FixedDataTableWidthHelper.adjustColumnGroupWidths(children, props.width);\n      columns = columnGroupSettings.columns;\n      columnGroups = columnGroupSettings.columnGroups;\n    } else {\n      columns = FixedDataTableWidthHelper.adjustColumnWidths(children, props.width);\n    }\n\n    var columnInfo = this._populateColumnsAndColumnData(columns, columnGroups, oldState);\n\n    if (this._columnToScrollTo !== undefined) {\n      // If selected column is a fixed column, don't scroll\n      var fixedColumnsCount = columnInfo.bodyFixedColumns.length;\n\n      if (this._columnToScrollTo >= fixedColumnsCount) {\n        var totalFixedColumnsWidth = 0;\n        var i, column;\n\n        for (i = 0; i < columnInfo.bodyFixedColumns.length; ++i) {\n          column = columnInfo.bodyFixedColumns[i];\n          totalFixedColumnsWidth += column.props.width;\n        }\n\n        var scrollableColumnIndex = Math.min(this._columnToScrollTo - fixedColumnsCount, columnInfo.bodyScrollableColumns.length - 1);\n        var previousColumnsWidth = 0;\n\n        for (i = 0; i < scrollableColumnIndex; ++i) {\n          column = columnInfo.bodyScrollableColumns[i];\n          previousColumnsWidth += column.props.width;\n        }\n\n        var availableScrollWidth = props.width - totalFixedColumnsWidth;\n        var selectedColumnWidth = columnInfo.bodyScrollableColumns[scrollableColumnIndex].props.width;\n        var minAcceptableScrollPosition = previousColumnsWidth + selectedColumnWidth - availableScrollWidth;\n\n        if (scrollX < minAcceptableScrollPosition) {\n          scrollX = minAcceptableScrollPosition;\n        }\n\n        if (scrollX > previousColumnsWidth) {\n          scrollX = previousColumnsWidth;\n        }\n      }\n\n      delete this._columnToScrollTo;\n    }\n\n    var useMaxHeight = props.height === undefined;\n    var height = Math.round(useMaxHeight ? props.maxHeight : props.height);\n    var totalHeightReserved = props.footerHeight + props.headerHeight + groupHeaderHeight + 2 * BORDER_HEIGHT;\n    var bodyHeight = height - totalHeightReserved;\n\n    var scrollContentHeight = this._scrollHelper.getContentHeight();\n\n    var totalHeightNeeded = scrollContentHeight + totalHeightReserved;\n    var scrollContentWidth = FixedDataTableWidthHelper.getTotalWidth(columns);\n    var horizontalScrollbarVisible = scrollContentWidth > props.width && props.overflowX !== 'hidden';\n\n    if (horizontalScrollbarVisible) {\n      bodyHeight -= Scrollbar.SIZE;\n      totalHeightNeeded += Scrollbar.SIZE;\n      totalHeightReserved += Scrollbar.SIZE;\n    }\n\n    var maxScrollX = Math.max(0, scrollContentWidth - props.width);\n    var maxScrollY = Math.max(0, scrollContentHeight - bodyHeight);\n    scrollX = Math.min(scrollX, maxScrollX);\n    scrollY = Math.min(scrollY, maxScrollY);\n\n    if (!maxScrollY) {\n      // no vertical scrollbar necessary, use the totals we tracked so we\n      // can shrink-to-fit vertically\n      if (useMaxHeight) {\n        height = totalHeightNeeded;\n      }\n\n      bodyHeight = totalHeightNeeded - totalHeightReserved;\n    }\n\n    this._scrollHelper.setViewportHeight(bodyHeight); // The order of elements in this object metters and bringing bodyHeight,\n    // height or useGroupHeader to the top can break various features\n\n\n    var newState = _extends({\n      isColumnResizing: oldState && oldState.isColumnResizing\n    }, columnInfo, props, {\n      columns: columns,\n      columnGroups: columnGroups,\n      columnResizingData: columnResizingData,\n      firstRowIndex: firstRowIndex,\n      firstRowOffset: firstRowOffset,\n      horizontalScrollbarVisible: horizontalScrollbarVisible,\n      maxScrollX: maxScrollX,\n      maxScrollY: maxScrollY,\n      reservedHeight: totalHeightReserved,\n      scrollContentHeight: scrollContentHeight,\n      scrollX: scrollX,\n      scrollY: scrollY,\n      // These properties may overwrite properties defined in\n      // columnInfo and props\n      bodyHeight: bodyHeight,\n      height: height,\n      groupHeaderHeight: groupHeaderHeight,\n      useGroupHeader: useGroupHeader\n    });\n\n    return newState;\n  },\n  _selectColumnElement: function _selectColumnElement(\n  /*string*/\n  type,\n  /*array*/\n  columns)\n  /*array*/\n  {\n    var newColumns = [];\n\n    for (var i = 0; i < columns.length; ++i) {\n      var column = columns[i];\n      newColumns.push(React.cloneElement(column, {\n        cell: type ? column.props[type] : column.props[CELL]\n      }));\n    }\n\n    return newColumns;\n  },\n  _splitColumnTypes: function _splitColumnTypes(\n  /*array*/\n  columns)\n  /*object*/\n  {\n    var fixedColumns = [];\n    var scrollableColumns = [];\n\n    for (var i = 0; i < columns.length; ++i) {\n      if (columns[i].props.fixed) {\n        fixedColumns.push(columns[i]);\n      } else {\n        scrollableColumns.push(columns[i]);\n      }\n    }\n\n    return {\n      fixed: fixedColumns,\n      scrollable: scrollableColumns\n    };\n  },\n  _onWheel: function _onWheel(\n  /*number*/\n  deltaX,\n  /*number*/\n  deltaY) {\n    if (this.isMounted()) {\n      if (!this._isScrolling) {\n        this._didScrollStart();\n      }\n\n      var x = this.state.scrollX;\n\n      if (Math.abs(deltaY) > Math.abs(deltaX) && this.props.overflowY !== 'hidden') {\n        var scrollState = this._scrollHelper.scrollBy(Math.round(deltaY));\n\n        var maxScrollY = Math.max(0, scrollState.contentHeight - this.state.bodyHeight);\n        this.setState({\n          firstRowIndex: scrollState.index,\n          firstRowOffset: scrollState.offset,\n          scrollY: scrollState.position,\n          scrollContentHeight: scrollState.contentHeight,\n          maxScrollY: maxScrollY\n        });\n      } else if (deltaX && this.props.overflowX !== 'hidden') {\n        x += deltaX;\n        x = x < 0 ? 0 : x;\n        x = x > this.state.maxScrollX ? this.state.maxScrollX : x;\n        this.setState({\n          scrollX: x\n        });\n      }\n\n      this._didScrollStop();\n    }\n  },\n  _onHorizontalScroll: function _onHorizontalScroll(\n  /*number*/\n  scrollPos) {\n    if (this.isMounted() && scrollPos !== this.state.scrollX) {\n      if (!this._isScrolling) {\n        this._didScrollStart();\n      }\n\n      this.setState({\n        scrollX: scrollPos\n      });\n\n      this._didScrollStop();\n    }\n  },\n  _onVerticalScroll: function _onVerticalScroll(\n  /*number*/\n  scrollPos) {\n    if (this.isMounted() && scrollPos !== this.state.scrollY) {\n      if (!this._isScrolling) {\n        this._didScrollStart();\n      }\n\n      var scrollState = this._scrollHelper.scrollTo(Math.round(scrollPos));\n\n      this.setState({\n        firstRowIndex: scrollState.index,\n        firstRowOffset: scrollState.offset,\n        scrollY: scrollState.position,\n        scrollContentHeight: scrollState.contentHeight\n      });\n\n      this._didScrollStop();\n    }\n  },\n  _didScrollStart: function _didScrollStart() {\n    if (this.isMounted() && !this._isScrolling) {\n      this._isScrolling = true;\n\n      if (this.props.onScrollStart) {\n        this.props.onScrollStart(this.state.scrollX, this.state.scrollY);\n      }\n    }\n  },\n  _didScrollStop: function _didScrollStop() {\n    if (this.isMounted() && this._isScrolling) {\n      this._isScrolling = false;\n      this.setState({\n        redraw: true\n      });\n\n      if (this.props.onScrollEnd) {\n        this.props.onScrollEnd(this.state.scrollX, this.state.scrollY);\n      }\n    }\n  }\n});\nvar HorizontalScrollbar = createReactClass({\n  mixins: [ReactComponentWithPureRenderMixin],\n  propTypes: {\n    contentSize: PropTypes.number.isRequired,\n    offset: PropTypes.number.isRequired,\n    onScroll: PropTypes.func.isRequired,\n    position: PropTypes.number.isRequired,\n    size: PropTypes.number.isRequired\n  },\n  render: function render()\n  /*object*/\n  {\n    var outerContainerStyle = {\n      height: Scrollbar.SIZE,\n      width: this.props.size\n    };\n    var innerContainerStyle = {\n      height: Scrollbar.SIZE,\n      position: 'absolute',\n      overflow: 'hidden',\n      width: this.props.size\n    };\n    translateDOMPositionXY(innerContainerStyle, 0, this.props.offset);\n    return React.createElement('div', {\n      className: joinClasses(cx('fixedDataTableLayout/horizontalScrollbar'), cx('public/fixedDataTable/horizontalScrollbar')),\n      style: outerContainerStyle\n    }, React.createElement('div', {\n      style: innerContainerStyle\n    }, React.createElement(Scrollbar, _extends({}, this.props, {\n      isOpaque: true,\n      orientation: 'horizontal',\n      offset: undefined\n    }))));\n  }\n});\nmodule.exports = FixedDataTable; // isColumnResizing should be overwritten by value from props if\n// avaialble","map":{"version":3,"sources":["C:/Versa/pagination/node_modules/fixed-data-table/internal/FixedDataTableNew.react.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","React","require","createReactClass","ReactComponentWithPureRenderMixin","ReactWheelHandler","Scrollbar","FixedDataTableBufferedRows","FixedDataTableColumnResizeHandle","FixedDataTableRow","FixedDataTableScrollHelper","FixedDataTableWidthHelper","cx","debounceCore","emptyFunction","invariant","joinClasses","shallowEqual","translateDOMPositionXY","PropTypes","ReactChildren","Children","EMPTY_OBJECT","BORDER_HEIGHT","HEADER","FOOTER","CELL","FixedDataTable","propTypes","width","number","isRequired","height","maxHeight","ownerHeight","overflowX","oneOf","overflowY","rowsCount","rowHeight","rowHeightGetter","func","rowClassNameGetter","groupHeaderHeight","headerHeight","footerHeight","scrollLeft","scrollToColumn","scrollTop","scrollToRow","onScrollStart","onScrollEnd","onContentHeightChange","onRowClick","onRowDoubleClick","onRowMouseDown","onRowMouseEnter","onRowMouseLeave","onColumnResizeEndCallback","isColumnResizing","bool","getDefaultProps","getInitialState","props","viewportHeight","undefined","_scrollHelper","scrollTo","_didScrollStop","_calculateState","componentWillMount","_rowToScrollTo","_columnToScrollTo","_wheelHandler","_onWheel","_shouldHandleWheelX","_shouldHandleWheelY","delta","Math","round","state","scrollX","maxScrollX","scrollY","maxScrollY","_reportContentHeight","scrollContentHeight","reservedHeight","requiredHeight","contentHeight","useMaxHeight","max","_contentHeight","componentDidMount","componentWillReceiveProps","nextProps","newOverflowX","newOverflowY","_didScrollStart","setState","componentDidUpdate","render","groupHeader","useGroupHeader","createElement","isScrolling","_isScrolling","className","index","zIndex","offsetTop","fixedColumns","groupHeaderFixedColumns","scrollableColumns","groupHeaderScrollableColumns","onColumnResize","_onColumnResize","showScrollbarX","showScrollbarY","scrollbarXHeight","SIZE","scrollbarYHeight","headerOffsetTop","bodyOffsetTop","bottomSectionOffset","footOffsetTop","bodyHeight","rowsContainerHeight","min","verticalScrollbar","size","contentSize","onScroll","_onVerticalScroll","verticalTop","position","horizontalScrollbar","scrollbarXWidth","HorizontalScrollbar","offset","_onHorizontalScroll","dragKnob","initialWidth","columnResizingData","minWidth","maxWidth","Number","MAX_VALUE","visible","leftOffset","left","knobHeight","initialEvent","onColumnResizeEnd","columnKey","footer","footFixedColumns","footScrollableColumns","rows","_renderRows","header","headFixedColumns","headScrollableColumns","topShadow","bottomShadow","style","top","onWheel","defaultRowHeight","firstRowIndex","firstRowOffset","bodyFixedColumns","rowGetter","bodyScrollableColumns","showLastRowBorder","rowPositionGetter","getRowPosition","combinedWidth","cellWidth","cellMinWidth","cellMaxWidth","event","clientX","clientY","preventDefault","_areColumnSettingsIdentical","oldColumns","newColumns","_populateColumnsAndColumnData","columns","columnGroups","oldState","canReuseColumnSettings","canReuseColumnGroupSettings","columnInfo","bodyColumnTypes","_splitColumnTypes","fixed","scrollable","headColumnTypes","_selectColumnElement","footColumnTypes","groupHeaderColumnTypes","children","forEach","child","type","__TableColumnGroup__","__TableColumn__","push","scrollState","scrollRowIntoView","setRowHeightGetter","columnGroupSettings","adjustColumnGroupWidths","adjustColumnWidths","fixedColumnsCount","totalFixedColumnsWidth","column","scrollableColumnIndex","previousColumnsWidth","availableScrollWidth","selectedColumnWidth","minAcceptableScrollPosition","totalHeightReserved","getContentHeight","totalHeightNeeded","scrollContentWidth","getTotalWidth","horizontalScrollbarVisible","setViewportHeight","newState","cloneElement","cell","deltaX","deltaY","isMounted","x","abs","scrollBy","scrollPos","redraw","mixins","outerContainerStyle","innerContainerStyle","overflow","isOpaque","orientation","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FixedDataTableNew.react\n * @typechecks\n * @noflow\n */\n\n/*eslint no-bitwise:1*/\n\n'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar React = require('./React');\nvar createReactClass = require('create-react-class');\nvar ReactComponentWithPureRenderMixin = require('./ReactComponentWithPureRenderMixin');\nvar ReactWheelHandler = require('./ReactWheelHandler');\nvar Scrollbar = require('./Scrollbar.react');\nvar FixedDataTableBufferedRows = require('./FixedDataTableBufferedRows.react');\nvar FixedDataTableColumnResizeHandle = require('./FixedDataTableColumnResizeHandle.react');\nvar FixedDataTableRow = require('./FixedDataTableRow.react');\nvar FixedDataTableScrollHelper = require('./FixedDataTableScrollHelper');\nvar FixedDataTableWidthHelper = require('./FixedDataTableWidthHelper');\n\nvar cx = require('./cx');\nvar debounceCore = require('./debounceCore');\nvar emptyFunction = require('./emptyFunction');\nvar invariant = require('./invariant');\nvar joinClasses = require('./joinClasses');\nvar shallowEqual = require('./shallowEqual');\nvar translateDOMPositionXY = require('./translateDOMPositionXY');\n\nvar PropTypes = require('prop-types');\nvar ReactChildren = React.Children;\n\nvar EMPTY_OBJECT = {};\nvar BORDER_HEIGHT = 1;\nvar HEADER = 'header';\nvar FOOTER = 'footer';\nvar CELL = 'cell';\n\n/**\n * Data grid component with fixed or scrollable header and columns.\n *\n * The layout of the data table is as follows:\n *\n * ```\n * +---------------------------------------------------+\n * | Fixed Column Group    | Scrollable Column Group   |\n * | Header                | Header                    |\n * |                       |                           |\n * +---------------------------------------------------+\n * |                       |                           |\n * | Fixed Header Columns  | Scrollable Header Columns |\n * |                       |                           |\n * +-----------------------+---------------------------+\n * |                       |                           |\n * | Fixed Body Columns    | Scrollable Body Columns   |\n * |                       |                           |\n * +-----------------------+---------------------------+\n * |                       |                           |\n * | Fixed Footer Columns  | Scrollable Footer Columns |\n * |                       |                           |\n * +-----------------------+---------------------------+\n * ```\n *\n * - Fixed Column Group Header: These are the headers for a group\n *   of columns if included in the table that do not scroll\n *   vertically or horizontally.\n *\n * - Scrollable Column Group Header: The header for a group of columns\n *   that do not move while scrolling vertically, but move horizontally\n *   with the horizontal scrolling.\n *\n * - Fixed Header Columns: The header columns that do not move while scrolling\n *   vertically or horizontally.\n *\n * - Scrollable Header Columns: The header columns that do not move\n *   while scrolling vertically, but move horizontally with the horizontal\n *   scrolling.\n *\n * - Fixed Body Columns: The body columns that do not move while scrolling\n *   horizontally, but move vertically with the vertical scrolling.\n *\n * - Scrollable Body Columns: The body columns that move while scrolling\n *   vertically or horizontally.\n */\nvar FixedDataTable = createReactClass({\n\n  propTypes: {\n\n    /**\n     * Pixel width of table. If all columns do not fit,\n     * a horizontal scrollbar will appear.\n     */\n    width: PropTypes.number.isRequired,\n\n    /**\n     * Pixel height of table. If all rows do not fit,\n     * a vertical scrollbar will appear.\n     *\n     * Either `height` or `maxHeight` must be specified.\n     */\n    height: PropTypes.number,\n\n    /**\n     * Maximum pixel height of table. If all rows do not fit,\n     * a vertical scrollbar will appear.\n     *\n     * Either `height` or `maxHeight` must be specified.\n     */\n    maxHeight: PropTypes.number,\n\n    /**\n     * Pixel height of table's owner, this is used in a managed scrolling\n     * situation when you want to slide the table up from below the fold\n     * without having to constantly update the height on every scroll tick.\n     * Instead, vary this property on scroll. By using `ownerHeight`, we\n     * over-render the table while making sure the footer and horizontal\n     * scrollbar of the table are visible when the current space for the table\n     * in view is smaller than the final, over-flowing height of table. It\n     * allows us to avoid resizing and reflowing table when it is moving in the\n     * view.\n     *\n     * This is used if `ownerHeight < height` (or `maxHeight`).\n     */\n    ownerHeight: PropTypes.number,\n\n    overflowX: PropTypes.oneOf(['hidden', 'auto']),\n    overflowY: PropTypes.oneOf(['hidden', 'auto']),\n\n    /**\n     * Number of rows in the table.\n     */\n    rowsCount: PropTypes.number.isRequired,\n\n    /**\n     * Pixel height of rows unless `rowHeightGetter` is specified and returns\n     * different value.\n     */\n    rowHeight: PropTypes.number.isRequired,\n\n    /**\n     * If specified, `rowHeightGetter(index)` is called for each row and the\n     * returned value overrides `rowHeight` for particular row.\n     */\n    rowHeightGetter: PropTypes.func,\n\n    /**\n     * To get any additional CSS classes that should be added to a row,\n     * `rowClassNameGetter(index)` is called.\n     */\n    rowClassNameGetter: PropTypes.func,\n\n    /**\n     * Pixel height of the column group header.\n     */\n    groupHeaderHeight: PropTypes.number,\n\n    /**\n     * Pixel height of header.\n     */\n    headerHeight: PropTypes.number.isRequired,\n\n    /**\n     * Pixel height of footer.\n     */\n    footerHeight: PropTypes.number,\n\n    /**\n     * Value of horizontal scroll.\n     */\n    scrollLeft: PropTypes.number,\n\n    /**\n     * Index of column to scroll to.\n     */\n    scrollToColumn: PropTypes.number,\n\n    /**\n     * Value of vertical scroll.\n     */\n    scrollTop: PropTypes.number,\n\n    /**\n     * Index of row to scroll to.\n     */\n    scrollToRow: PropTypes.number,\n\n    /**\n     * Callback that is called when scrolling starts with current horizontal\n     * and vertical scroll values.\n     */\n    onScrollStart: PropTypes.func,\n\n    /**\n     * Callback that is called when scrolling ends or stops with new horizontal\n     * and vertical scroll values.\n     */\n    onScrollEnd: PropTypes.func,\n\n    /**\n     * Callback that is called when `rowHeightGetter` returns a different height\n     * for a row than the `rowHeight` prop. This is necessary because initially\n     * table estimates heights of some parts of the content.\n     */\n    onContentHeightChange: PropTypes.func,\n\n    /**\n     * Callback that is called when a row is clicked.\n     */\n    onRowClick: PropTypes.func,\n\n    /**\n     * Callback that is called when a row is double clicked.\n     */\n    onRowDoubleClick: PropTypes.func,\n\n    /**\n     * Callback that is called when a mouse-down event happens on a row.\n     */\n    onRowMouseDown: PropTypes.func,\n\n    /**\n     * Callback that is called when a mouse-enter event happens on a row.\n     */\n    onRowMouseEnter: PropTypes.func,\n\n    /**\n     * Callback that is called when a mouse-leave event happens on a row.\n     */\n    onRowMouseLeave: PropTypes.func,\n\n    /**\n     * Callback that is called when resizer has been released\n     * and column needs to be updated.\n     *\n     * Required if the isResizable property is true on any column.\n     *\n     * ```\n     * function(\n     *   newColumnWidth: number,\n     *   columnKey: string,\n     * )\n     * ```\n     */\n    onColumnResizeEndCallback: PropTypes.func,\n\n    /**\n     * Whether a column is currently being resized.\n     */\n    isColumnResizing: PropTypes.bool\n  },\n\n  getDefaultProps: function getDefaultProps() /*object*/{\n    return {\n      footerHeight: 0,\n      groupHeaderHeight: 0,\n      headerHeight: 0,\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n  },\n\n  getInitialState: function getInitialState() /*object*/{\n    var props = this.props;\n    var viewportHeight = (props.height === undefined ? props.maxHeight : props.height) - (props.headerHeight || 0) - (props.footerHeight || 0) - (props.groupHeaderHeight || 0);\n    this._scrollHelper = new FixedDataTableScrollHelper(props.rowsCount, props.rowHeight, viewportHeight, props.rowHeightGetter);\n    if (props.scrollTop) {\n      this._scrollHelper.scrollTo(props.scrollTop);\n    }\n    this._didScrollStop = debounceCore(this._didScrollStop, 200, this);\n\n    return this._calculateState(this.props);\n  },\n\n  componentWillMount: function componentWillMount() {\n    var scrollToRow = this.props.scrollToRow;\n    if (scrollToRow !== undefined && scrollToRow !== null) {\n      this._rowToScrollTo = scrollToRow;\n    }\n    var scrollToColumn = this.props.scrollToColumn;\n    if (scrollToColumn !== undefined && scrollToColumn !== null) {\n      this._columnToScrollTo = scrollToColumn;\n    }\n    this._wheelHandler = new ReactWheelHandler(this._onWheel, this._shouldHandleWheelX, this._shouldHandleWheelY);\n  },\n\n  _shouldHandleWheelX: function _shouldHandleWheelX( /*number*/delta) /*boolean*/{\n    if (this.props.overflowX === 'hidden') {\n      return false;\n    }\n\n    delta = Math.round(delta);\n    if (delta === 0) {\n      return false;\n    }\n\n    return delta < 0 && this.state.scrollX > 0 || delta >= 0 && this.state.scrollX < this.state.maxScrollX;\n  },\n\n  _shouldHandleWheelY: function _shouldHandleWheelY( /*number*/delta) /*boolean*/{\n    if (this.props.overflowY === 'hidden' || delta === 0) {\n      return false;\n    }\n\n    delta = Math.round(delta);\n    if (delta === 0) {\n      return false;\n    }\n\n    return delta < 0 && this.state.scrollY > 0 || delta >= 0 && this.state.scrollY < this.state.maxScrollY;\n  },\n\n  _reportContentHeight: function _reportContentHeight() {\n    var scrollContentHeight = this.state.scrollContentHeight;\n    var reservedHeight = this.state.reservedHeight;\n    var requiredHeight = scrollContentHeight + reservedHeight;\n    var contentHeight;\n    var useMaxHeight = this.props.height === undefined;\n    if (useMaxHeight && this.props.maxHeight > requiredHeight) {\n      contentHeight = requiredHeight;\n    } else if (this.state.height > requiredHeight && this.props.ownerHeight) {\n      contentHeight = Math.max(requiredHeight, this.props.ownerHeight);\n    } else {\n      contentHeight = this.state.height + this.state.maxScrollY;\n    }\n    if (contentHeight !== this._contentHeight && this.props.onContentHeightChange) {\n      this.props.onContentHeightChange(contentHeight);\n    }\n    this._contentHeight = contentHeight;\n  },\n\n  componentDidMount: function componentDidMount() {\n    this._reportContentHeight();\n  },\n\n  componentWillReceiveProps: function componentWillReceiveProps( /*object*/nextProps) {\n    var scrollToRow = nextProps.scrollToRow;\n    if (scrollToRow !== undefined && scrollToRow !== null) {\n      this._rowToScrollTo = scrollToRow;\n    }\n    var scrollToColumn = nextProps.scrollToColumn;\n    if (scrollToColumn !== undefined && scrollToColumn !== null) {\n      this._columnToScrollTo = scrollToColumn;\n    }\n\n    var newOverflowX = nextProps.overflowX;\n    var newOverflowY = nextProps.overflowY;\n    if (newOverflowX !== this.props.overflowX || newOverflowY !== this.props.overflowY) {\n      this._wheelHandler = new ReactWheelHandler(this._onWheel, newOverflowX !== 'hidden', // Should handle horizontal scroll\n      newOverflowY !== 'hidden' // Should handle vertical scroll\n      );\n    }\n\n    // In the case of controlled scrolling, notify.\n    if (this.props.ownerHeight !== nextProps.ownerHeight || this.props.scrollTop !== nextProps.scrollTop) {\n      this._didScrollStart();\n    }\n    this._didScrollStop();\n\n    this.setState(this._calculateState(nextProps, this.state));\n  },\n\n  componentDidUpdate: function componentDidUpdate() {\n    this._reportContentHeight();\n  },\n\n  render: function render() /*object*/{\n    var state = this.state;\n    var props = this.props;\n\n    var groupHeader;\n    if (state.useGroupHeader) {\n      groupHeader = React.createElement(FixedDataTableRow, {\n        key: 'group_header',\n        isScrolling: this._isScrolling,\n        className: joinClasses(cx('fixedDataTableLayout/header'), cx('public/fixedDataTable/header')),\n        width: state.width,\n        height: state.groupHeaderHeight,\n        index: 0,\n        zIndex: 1,\n        offsetTop: 0,\n        scrollLeft: state.scrollX,\n        fixedColumns: state.groupHeaderFixedColumns,\n        scrollableColumns: state.groupHeaderScrollableColumns,\n        onColumnResize: this._onColumnResize\n      });\n    }\n\n    var maxScrollY = this.state.maxScrollY;\n    var showScrollbarX = state.maxScrollX > 0 && state.overflowX !== 'hidden';\n    var showScrollbarY = maxScrollY > 0 && state.overflowY !== 'hidden';\n    var scrollbarXHeight = showScrollbarX ? Scrollbar.SIZE : 0;\n    var scrollbarYHeight = state.height - scrollbarXHeight - 2 * BORDER_HEIGHT - state.footerHeight;\n\n    var headerOffsetTop = state.useGroupHeader ? state.groupHeaderHeight : 0;\n    var bodyOffsetTop = headerOffsetTop + state.headerHeight;\n    scrollbarYHeight -= bodyOffsetTop;\n    var bottomSectionOffset = 0;\n    var footOffsetTop = props.maxHeight != null ? bodyOffsetTop + state.bodyHeight : bodyOffsetTop + scrollbarYHeight;\n    var rowsContainerHeight = footOffsetTop + state.footerHeight;\n\n    if (props.ownerHeight !== undefined && props.ownerHeight < state.height) {\n      bottomSectionOffset = props.ownerHeight - state.height;\n\n      footOffsetTop = Math.min(footOffsetTop, props.ownerHeight - state.footerHeight - scrollbarXHeight);\n\n      scrollbarYHeight = Math.max(0, footOffsetTop - bodyOffsetTop);\n    }\n\n    var verticalScrollbar;\n    if (showScrollbarY) {\n      verticalScrollbar = React.createElement(Scrollbar, {\n        size: scrollbarYHeight,\n        contentSize: scrollbarYHeight + maxScrollY,\n        onScroll: this._onVerticalScroll,\n        verticalTop: bodyOffsetTop,\n        position: state.scrollY\n      });\n    }\n\n    var horizontalScrollbar;\n    if (showScrollbarX) {\n      var scrollbarXWidth = state.width;\n      horizontalScrollbar = React.createElement(HorizontalScrollbar, {\n        contentSize: scrollbarXWidth + state.maxScrollX,\n        offset: bottomSectionOffset,\n        onScroll: this._onHorizontalScroll,\n        position: state.scrollX,\n        size: scrollbarXWidth\n      });\n    }\n\n    var dragKnob = React.createElement(FixedDataTableColumnResizeHandle, {\n      height: state.height,\n      initialWidth: state.columnResizingData.width || 0,\n      minWidth: state.columnResizingData.minWidth || 0,\n      maxWidth: state.columnResizingData.maxWidth || Number.MAX_VALUE,\n      visible: !!state.isColumnResizing,\n      leftOffset: state.columnResizingData.left || 0,\n      knobHeight: state.headerHeight,\n      initialEvent: state.columnResizingData.initialEvent,\n      onColumnResizeEnd: props.onColumnResizeEndCallback,\n      columnKey: state.columnResizingData.key\n    });\n\n    var footer = null;\n    if (state.footerHeight) {\n      footer = React.createElement(FixedDataTableRow, {\n        key: 'footer',\n        isScrolling: this._isScrolling,\n        className: joinClasses(cx('fixedDataTableLayout/footer'), cx('public/fixedDataTable/footer')),\n        width: state.width,\n        height: state.footerHeight,\n        index: -1,\n        zIndex: 1,\n        offsetTop: footOffsetTop,\n        fixedColumns: state.footFixedColumns,\n        scrollableColumns: state.footScrollableColumns,\n        scrollLeft: state.scrollX\n      });\n    }\n\n    var rows = this._renderRows(bodyOffsetTop);\n\n    var header = React.createElement(FixedDataTableRow, {\n      key: 'header',\n      isScrolling: this._isScrolling,\n      className: joinClasses(cx('fixedDataTableLayout/header'), cx('public/fixedDataTable/header')),\n      width: state.width,\n      height: state.headerHeight,\n      index: -1,\n      zIndex: 1,\n      offsetTop: headerOffsetTop,\n      scrollLeft: state.scrollX,\n      fixedColumns: state.headFixedColumns,\n      scrollableColumns: state.headScrollableColumns,\n      onColumnResize: this._onColumnResize\n    });\n\n    var topShadow;\n    var bottomShadow;\n    if (state.scrollY) {\n      topShadow = React.createElement('div', {\n        className: joinClasses(cx('fixedDataTableLayout/topShadow'), cx('public/fixedDataTable/topShadow')),\n        style: { top: bodyOffsetTop }\n      });\n    }\n\n    if (state.ownerHeight != null && state.ownerHeight < state.height && state.scrollContentHeight + state.reservedHeight > state.ownerHeight || state.scrollY < maxScrollY) {\n      bottomShadow = React.createElement('div', {\n        className: joinClasses(cx('fixedDataTableLayout/bottomShadow'), cx('public/fixedDataTable/bottomShadow')),\n        style: { top: footOffsetTop }\n      });\n    }\n\n    return React.createElement(\n      'div',\n      {\n        className: joinClasses(cx('fixedDataTableLayout/main'), cx('public/fixedDataTable/main')),\n        onWheel: this._wheelHandler.onWheel,\n        style: { height: state.height, width: state.width } },\n      React.createElement(\n        'div',\n        {\n          className: cx('fixedDataTableLayout/rowsContainer'),\n          style: { height: rowsContainerHeight, width: state.width } },\n        dragKnob,\n        groupHeader,\n        header,\n        rows,\n        footer,\n        topShadow,\n        bottomShadow\n      ),\n      verticalScrollbar,\n      horizontalScrollbar\n    );\n  },\n\n  _renderRows: function _renderRows( /*number*/offsetTop) /*object*/{\n    var state = this.state;\n\n    return React.createElement(FixedDataTableBufferedRows, {\n      isScrolling: this._isScrolling,\n      defaultRowHeight: state.rowHeight,\n      firstRowIndex: state.firstRowIndex,\n      firstRowOffset: state.firstRowOffset,\n      fixedColumns: state.bodyFixedColumns,\n      height: state.bodyHeight,\n      offsetTop: offsetTop,\n      onRowClick: state.onRowClick,\n      onRowDoubleClick: state.onRowDoubleClick,\n      onRowMouseDown: state.onRowMouseDown,\n      onRowMouseEnter: state.onRowMouseEnter,\n      onRowMouseLeave: state.onRowMouseLeave,\n      rowClassNameGetter: state.rowClassNameGetter,\n      rowsCount: state.rowsCount,\n      rowGetter: state.rowGetter,\n      rowHeightGetter: state.rowHeightGetter,\n      scrollLeft: state.scrollX,\n      scrollableColumns: state.bodyScrollableColumns,\n      showLastRowBorder: true,\n      width: state.width,\n      rowPositionGetter: this._scrollHelper.getRowPosition\n    });\n  },\n\n  /**\n   * This is called when a cell that is in the header of a column has its\n   * resizer knob clicked on. It displays the resizer and puts in the correct\n   * location on the table.\n   */\n  _onColumnResize: function _onColumnResize(\n  /*number*/combinedWidth,\n  /*number*/leftOffset,\n  /*number*/cellWidth,\n  /*?number*/cellMinWidth,\n  /*?number*/cellMaxWidth,\n  /*number|string*/columnKey,\n  /*object*/event) {\n    this.setState({\n      isColumnResizing: true,\n      columnResizingData: {\n        left: leftOffset + combinedWidth - cellWidth,\n        width: cellWidth,\n        minWidth: cellMinWidth,\n        maxWidth: cellMaxWidth,\n        initialEvent: {\n          clientX: event.clientX,\n          clientY: event.clientY,\n          preventDefault: emptyFunction\n        },\n        key: columnKey\n      }\n    });\n  },\n\n  _areColumnSettingsIdentical: function _areColumnSettingsIdentical(oldColumns, newColumns) {\n    if (oldColumns.length !== newColumns.length) {\n      return false;\n    }\n    for (var index = 0; index < oldColumns.length; ++index) {\n      if (!shallowEqual(oldColumns[index].props, newColumns[index].props)) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  _populateColumnsAndColumnData: function _populateColumnsAndColumnData(columns, columnGroups, oldState) {\n    var canReuseColumnSettings = false;\n    var canReuseColumnGroupSettings = false;\n\n    if (oldState && oldState.columns) {\n      canReuseColumnSettings = this._areColumnSettingsIdentical(columns, oldState.columns);\n    }\n    if (oldState && oldState.columnGroups && columnGroups) {\n      canReuseColumnGroupSettings = this._areColumnSettingsIdentical(columnGroups, oldState.columnGroups);\n    }\n\n    var columnInfo = {};\n    if (canReuseColumnSettings) {\n      columnInfo.bodyFixedColumns = oldState.bodyFixedColumns;\n      columnInfo.bodyScrollableColumns = oldState.bodyScrollableColumns;\n      columnInfo.headFixedColumns = oldState.headFixedColumns;\n      columnInfo.headScrollableColumns = oldState.headScrollableColumns;\n      columnInfo.footFixedColumns = oldState.footFixedColumns;\n      columnInfo.footScrollableColumns = oldState.footScrollableColumns;\n    } else {\n      var bodyColumnTypes = this._splitColumnTypes(columns);\n      columnInfo.bodyFixedColumns = bodyColumnTypes.fixed;\n      columnInfo.bodyScrollableColumns = bodyColumnTypes.scrollable;\n\n      var headColumnTypes = this._splitColumnTypes(this._selectColumnElement(HEADER, columns));\n      columnInfo.headFixedColumns = headColumnTypes.fixed;\n      columnInfo.headScrollableColumns = headColumnTypes.scrollable;\n\n      var footColumnTypes = this._splitColumnTypes(this._selectColumnElement(FOOTER, columns));\n      columnInfo.footFixedColumns = footColumnTypes.fixed;\n      columnInfo.footScrollableColumns = footColumnTypes.scrollable;\n    }\n\n    if (canReuseColumnGroupSettings) {\n      columnInfo.groupHeaderFixedColumns = oldState.groupHeaderFixedColumns;\n      columnInfo.groupHeaderScrollableColumns = oldState.groupHeaderScrollableColumns;\n    } else {\n      if (columnGroups) {\n        var groupHeaderColumnTypes = this._splitColumnTypes(this._selectColumnElement(HEADER, columnGroups));\n        columnInfo.groupHeaderFixedColumns = groupHeaderColumnTypes.fixed;\n        columnInfo.groupHeaderScrollableColumns = groupHeaderColumnTypes.scrollable;\n      }\n    }\n\n    return columnInfo;\n  },\n\n  _calculateState: function _calculateState( /*object*/props, /*?object*/oldState) /*object*/{\n    invariant(props.height !== undefined || props.maxHeight !== undefined, 'You must set either a height or a maxHeight');\n\n    var children = [];\n    ReactChildren.forEach(props.children, function (child, index) {\n      if (child == null) {\n        return;\n      }\n      invariant(child.type.__TableColumnGroup__ || child.type.__TableColumn__, 'child type should be <FixedDataTableColumn /> or ' + '<FixedDataTableColumnGroup />');\n      children.push(child);\n    });\n\n    var useGroupHeader = false;\n    if (children.length && children[0].type.__TableColumnGroup__) {\n      useGroupHeader = true;\n    }\n\n    var firstRowIndex = oldState && oldState.firstRowIndex || 0;\n    var firstRowOffset = oldState && oldState.firstRowOffset || 0;\n    var scrollX, scrollY;\n    if (oldState && props.overflowX !== 'hidden') {\n      scrollX = oldState.scrollX;\n    } else {\n      scrollX = props.scrollLeft;\n    }\n    if (oldState && props.overflowY !== 'hidden') {\n      scrollY = oldState.scrollY;\n    } else {\n      scrollState = this._scrollHelper.scrollTo(props.scrollTop);\n      firstRowIndex = scrollState.index;\n      firstRowOffset = scrollState.offset;\n      scrollY = scrollState.position;\n    }\n\n    if (this._rowToScrollTo !== undefined) {\n      scrollState = this._scrollHelper.scrollRowIntoView(this._rowToScrollTo);\n      firstRowIndex = scrollState.index;\n      firstRowOffset = scrollState.offset;\n      scrollY = scrollState.position;\n      delete this._rowToScrollTo;\n    }\n\n    var groupHeaderHeight = useGroupHeader ? props.groupHeaderHeight : 0;\n\n    if (oldState && props.rowsCount !== oldState.rowsCount) {\n      // Number of rows changed, try to scroll to the row from before the\n      // change\n      var viewportHeight = (props.height === undefined ? props.maxHeight : props.height) - (props.headerHeight || 0) - (props.footerHeight || 0) - (props.groupHeaderHeight || 0);\n      this._scrollHelper = new FixedDataTableScrollHelper(props.rowsCount, props.rowHeight, viewportHeight, props.rowHeightGetter);\n      var scrollState = this._scrollHelper.scrollToRow(firstRowIndex, firstRowOffset);\n      firstRowIndex = scrollState.index;\n      firstRowOffset = scrollState.offset;\n      scrollY = scrollState.position;\n    } else if (oldState && props.rowHeightGetter !== oldState.rowHeightGetter) {\n      this._scrollHelper.setRowHeightGetter(props.rowHeightGetter);\n    }\n\n    var columnResizingData;\n    if (props.isColumnResizing) {\n      columnResizingData = oldState && oldState.columnResizingData;\n    } else {\n      columnResizingData = EMPTY_OBJECT;\n    }\n\n    var columns;\n    var columnGroups;\n\n    if (useGroupHeader) {\n      var columnGroupSettings = FixedDataTableWidthHelper.adjustColumnGroupWidths(children, props.width);\n      columns = columnGroupSettings.columns;\n      columnGroups = columnGroupSettings.columnGroups;\n    } else {\n      columns = FixedDataTableWidthHelper.adjustColumnWidths(children, props.width);\n    }\n\n    var columnInfo = this._populateColumnsAndColumnData(columns, columnGroups, oldState);\n\n    if (this._columnToScrollTo !== undefined) {\n      // If selected column is a fixed column, don't scroll\n      var fixedColumnsCount = columnInfo.bodyFixedColumns.length;\n      if (this._columnToScrollTo >= fixedColumnsCount) {\n        var totalFixedColumnsWidth = 0;\n        var i, column;\n        for (i = 0; i < columnInfo.bodyFixedColumns.length; ++i) {\n          column = columnInfo.bodyFixedColumns[i];\n          totalFixedColumnsWidth += column.props.width;\n        }\n\n        var scrollableColumnIndex = Math.min(this._columnToScrollTo - fixedColumnsCount, columnInfo.bodyScrollableColumns.length - 1);\n\n        var previousColumnsWidth = 0;\n        for (i = 0; i < scrollableColumnIndex; ++i) {\n          column = columnInfo.bodyScrollableColumns[i];\n          previousColumnsWidth += column.props.width;\n        }\n\n        var availableScrollWidth = props.width - totalFixedColumnsWidth;\n        var selectedColumnWidth = columnInfo.bodyScrollableColumns[scrollableColumnIndex].props.width;\n        var minAcceptableScrollPosition = previousColumnsWidth + selectedColumnWidth - availableScrollWidth;\n\n        if (scrollX < minAcceptableScrollPosition) {\n          scrollX = minAcceptableScrollPosition;\n        }\n\n        if (scrollX > previousColumnsWidth) {\n          scrollX = previousColumnsWidth;\n        }\n      }\n      delete this._columnToScrollTo;\n    }\n\n    var useMaxHeight = props.height === undefined;\n    var height = Math.round(useMaxHeight ? props.maxHeight : props.height);\n    var totalHeightReserved = props.footerHeight + props.headerHeight + groupHeaderHeight + 2 * BORDER_HEIGHT;\n    var bodyHeight = height - totalHeightReserved;\n    var scrollContentHeight = this._scrollHelper.getContentHeight();\n    var totalHeightNeeded = scrollContentHeight + totalHeightReserved;\n    var scrollContentWidth = FixedDataTableWidthHelper.getTotalWidth(columns);\n\n    var horizontalScrollbarVisible = scrollContentWidth > props.width && props.overflowX !== 'hidden';\n\n    if (horizontalScrollbarVisible) {\n      bodyHeight -= Scrollbar.SIZE;\n      totalHeightNeeded += Scrollbar.SIZE;\n      totalHeightReserved += Scrollbar.SIZE;\n    }\n\n    var maxScrollX = Math.max(0, scrollContentWidth - props.width);\n    var maxScrollY = Math.max(0, scrollContentHeight - bodyHeight);\n    scrollX = Math.min(scrollX, maxScrollX);\n    scrollY = Math.min(scrollY, maxScrollY);\n\n    if (!maxScrollY) {\n      // no vertical scrollbar necessary, use the totals we tracked so we\n      // can shrink-to-fit vertically\n      if (useMaxHeight) {\n        height = totalHeightNeeded;\n      }\n      bodyHeight = totalHeightNeeded - totalHeightReserved;\n    }\n\n    this._scrollHelper.setViewportHeight(bodyHeight);\n\n    // The order of elements in this object metters and bringing bodyHeight,\n    // height or useGroupHeader to the top can break various features\n    var newState = _extends({\n      isColumnResizing: oldState && oldState.isColumnResizing\n    }, columnInfo, props, {\n\n      columns: columns,\n      columnGroups: columnGroups,\n      columnResizingData: columnResizingData,\n      firstRowIndex: firstRowIndex,\n      firstRowOffset: firstRowOffset,\n      horizontalScrollbarVisible: horizontalScrollbarVisible,\n      maxScrollX: maxScrollX,\n      maxScrollY: maxScrollY,\n      reservedHeight: totalHeightReserved,\n      scrollContentHeight: scrollContentHeight,\n      scrollX: scrollX,\n      scrollY: scrollY,\n\n      // These properties may overwrite properties defined in\n      // columnInfo and props\n      bodyHeight: bodyHeight,\n      height: height,\n      groupHeaderHeight: groupHeaderHeight,\n      useGroupHeader: useGroupHeader\n    });\n\n    return newState;\n  },\n\n  _selectColumnElement: function _selectColumnElement( /*string*/type, /*array*/columns) /*array*/{\n    var newColumns = [];\n    for (var i = 0; i < columns.length; ++i) {\n      var column = columns[i];\n      newColumns.push(React.cloneElement(column, {\n        cell: type ? column.props[type] : column.props[CELL]\n      }));\n    }\n    return newColumns;\n  },\n\n  _splitColumnTypes: function _splitColumnTypes( /*array*/columns) /*object*/{\n    var fixedColumns = [];\n    var scrollableColumns = [];\n    for (var i = 0; i < columns.length; ++i) {\n      if (columns[i].props.fixed) {\n        fixedColumns.push(columns[i]);\n      } else {\n        scrollableColumns.push(columns[i]);\n      }\n    }\n    return {\n      fixed: fixedColumns,\n      scrollable: scrollableColumns\n    };\n  },\n\n  _onWheel: function _onWheel( /*number*/deltaX, /*number*/deltaY) {\n    if (this.isMounted()) {\n      if (!this._isScrolling) {\n        this._didScrollStart();\n      }\n      var x = this.state.scrollX;\n      if (Math.abs(deltaY) > Math.abs(deltaX) && this.props.overflowY !== 'hidden') {\n        var scrollState = this._scrollHelper.scrollBy(Math.round(deltaY));\n        var maxScrollY = Math.max(0, scrollState.contentHeight - this.state.bodyHeight);\n        this.setState({\n          firstRowIndex: scrollState.index,\n          firstRowOffset: scrollState.offset,\n          scrollY: scrollState.position,\n          scrollContentHeight: scrollState.contentHeight,\n          maxScrollY: maxScrollY\n        });\n      } else if (deltaX && this.props.overflowX !== 'hidden') {\n        x += deltaX;\n        x = x < 0 ? 0 : x;\n        x = x > this.state.maxScrollX ? this.state.maxScrollX : x;\n        this.setState({\n          scrollX: x\n        });\n      }\n\n      this._didScrollStop();\n    }\n  },\n\n  _onHorizontalScroll: function _onHorizontalScroll( /*number*/scrollPos) {\n    if (this.isMounted() && scrollPos !== this.state.scrollX) {\n      if (!this._isScrolling) {\n        this._didScrollStart();\n      }\n      this.setState({\n        scrollX: scrollPos\n      });\n      this._didScrollStop();\n    }\n  },\n\n  _onVerticalScroll: function _onVerticalScroll( /*number*/scrollPos) {\n    if (this.isMounted() && scrollPos !== this.state.scrollY) {\n      if (!this._isScrolling) {\n        this._didScrollStart();\n      }\n      var scrollState = this._scrollHelper.scrollTo(Math.round(scrollPos));\n      this.setState({\n        firstRowIndex: scrollState.index,\n        firstRowOffset: scrollState.offset,\n        scrollY: scrollState.position,\n        scrollContentHeight: scrollState.contentHeight\n      });\n      this._didScrollStop();\n    }\n  },\n\n  _didScrollStart: function _didScrollStart() {\n    if (this.isMounted() && !this._isScrolling) {\n      this._isScrolling = true;\n      if (this.props.onScrollStart) {\n        this.props.onScrollStart(this.state.scrollX, this.state.scrollY);\n      }\n    }\n  },\n\n  _didScrollStop: function _didScrollStop() {\n    if (this.isMounted() && this._isScrolling) {\n      this._isScrolling = false;\n      this.setState({ redraw: true });\n      if (this.props.onScrollEnd) {\n        this.props.onScrollEnd(this.state.scrollX, this.state.scrollY);\n      }\n    }\n  }\n});\n\nvar HorizontalScrollbar = createReactClass({\n  mixins: [ReactComponentWithPureRenderMixin],\n  propTypes: {\n    contentSize: PropTypes.number.isRequired,\n    offset: PropTypes.number.isRequired,\n    onScroll: PropTypes.func.isRequired,\n    position: PropTypes.number.isRequired,\n    size: PropTypes.number.isRequired\n  },\n\n  render: function render() /*object*/{\n    var outerContainerStyle = {\n      height: Scrollbar.SIZE,\n      width: this.props.size\n    };\n    var innerContainerStyle = {\n      height: Scrollbar.SIZE,\n      position: 'absolute',\n      overflow: 'hidden',\n      width: this.props.size\n    };\n    translateDOMPositionXY(innerContainerStyle, 0, this.props.offset);\n\n    return React.createElement(\n      'div',\n      {\n        className: joinClasses(cx('fixedDataTableLayout/horizontalScrollbar'), cx('public/fixedDataTable/horizontalScrollbar')),\n        style: outerContainerStyle },\n      React.createElement(\n        'div',\n        { style: innerContainerStyle },\n        React.createElement(Scrollbar, _extends({}, this.props, {\n          isOpaque: true,\n          orientation: 'horizontal',\n          offset: undefined\n        }))\n      )\n    );\n  }\n});\n\nmodule.exports = FixedDataTable;\n// isColumnResizing should be overwritten by value from props if\n// avaialble"]},"metadata":{},"sourceType":"script"}