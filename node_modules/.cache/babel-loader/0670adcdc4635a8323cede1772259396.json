{"ast":null,"code":"/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FixedDataTableRowBuffer\n * @typechecks\n */\n'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\n\nvar IntegerBufferSet = require('./IntegerBufferSet');\n\nvar clamp = require('./clamp');\n\nvar invariant = require('./invariant');\n\nvar MIN_BUFFER_ROWS = 3;\nvar MAX_BUFFER_ROWS = 6; // FixedDataTableRowBuffer is a helper class that executes row buffering\n// logic for FixedDataTable. It figures out which rows should be rendered\n// and in which positions.\n\nvar FixedDataTableRowBuffer = function () {\n  function FixedDataTableRowBuffer(\n  /*number*/\n  rowsCount,\n  /*number*/\n  defaultRowHeight,\n  /*number*/\n  viewportHeight,\n  /*?function*/\n  rowHeightGetter) {\n    _classCallCheck(this, FixedDataTableRowBuffer);\n\n    invariant(defaultRowHeight !== 0, \"defaultRowHeight musn't be equal 0 in FixedDataTableRowBuffer\");\n    this._bufferSet = new IntegerBufferSet();\n    this._defaultRowHeight = defaultRowHeight;\n    this._viewportRowsBegin = 0;\n    this._viewportRowsEnd = 0;\n    this._maxVisibleRowCount = Math.ceil(viewportHeight / defaultRowHeight) + 1;\n    this._bufferRowsCount = clamp(Math.floor(this._maxVisibleRowCount / 2), MIN_BUFFER_ROWS, MAX_BUFFER_ROWS);\n    this._rowsCount = rowsCount;\n    this._rowHeightGetter = rowHeightGetter;\n    this._rows = [];\n    this._viewportHeight = viewportHeight;\n    this.getRows = this.getRows.bind(this);\n    this.getRowsWithUpdatedBuffer = this.getRowsWithUpdatedBuffer.bind(this);\n  }\n\n  _createClass(FixedDataTableRowBuffer, [{\n    key: 'getRowsWithUpdatedBuffer',\n    value: function getRowsWithUpdatedBuffer()\n    /*array*/\n    {\n      var remainingBufferRows = 2 * this._bufferRowsCount;\n      var bufferRowIndex = Math.max(this._viewportRowsBegin - this._bufferRowsCount, 0);\n\n      while (bufferRowIndex < this._viewportRowsBegin) {\n        this._addRowToBuffer(bufferRowIndex, this._viewportRowsBegin, this._viewportRowsEnd - 1);\n\n        bufferRowIndex++;\n        remainingBufferRows--;\n      }\n\n      bufferRowIndex = this._viewportRowsEnd;\n\n      while (bufferRowIndex < this._rowsCount && remainingBufferRows > 0) {\n        this._addRowToBuffer(bufferRowIndex, this._viewportRowsBegin, this._viewportRowsEnd - 1);\n\n        bufferRowIndex++;\n        remainingBufferRows--;\n      }\n\n      return this._rows;\n    }\n  }, {\n    key: 'getRows',\n    value: function getRows(\n    /*number*/\n    firstRowIndex,\n    /*number*/\n    firstRowOffset)\n    /*array*/\n    {\n      var top = firstRowOffset;\n      var totalHeight = top;\n      var rowIndex = firstRowIndex;\n      var endIndex = Math.min(firstRowIndex + this._maxVisibleRowCount, this._rowsCount);\n      this._viewportRowsBegin = firstRowIndex;\n\n      while (rowIndex < endIndex || totalHeight < this._viewportHeight && rowIndex < this._rowsCount) {\n        this._addRowToBuffer(rowIndex, firstRowIndex, endIndex - 1);\n\n        totalHeight += this._rowHeightGetter(rowIndex);\n        ++rowIndex; // Store index after the last viewport row as end, to be able to\n        // distinguish when there are no rows rendered in viewport\n\n        this._viewportRowsEnd = rowIndex;\n      }\n\n      return this._rows;\n    }\n  }, {\n    key: '_addRowToBuffer',\n    value: function _addRowToBuffer(\n    /*number*/\n    rowIndex,\n    /*number*/\n    firstViewportRowIndex,\n    /*number*/\n    lastViewportRowIndex) {\n      var rowPosition = this._bufferSet.getValuePosition(rowIndex);\n\n      var viewportRowsCount = lastViewportRowIndex - firstViewportRowIndex + 1;\n      var allowedRowsCount = viewportRowsCount + this._bufferRowsCount * 2;\n\n      if (rowPosition === null && this._bufferSet.getSize() >= allowedRowsCount) {\n        rowPosition = this._bufferSet.replaceFurthestValuePosition(firstViewportRowIndex, lastViewportRowIndex, rowIndex);\n      }\n\n      if (rowPosition === null) {\n        // We can't reuse any of existing positions for this row. We have to\n        // create new position\n        rowPosition = this._bufferSet.getNewPositionForValue(rowIndex);\n        this._rows[rowPosition] = rowIndex;\n      } else {\n        // This row already is in the table with rowPosition position or it\n        // can replace row that is in that position\n        this._rows[rowPosition] = rowIndex;\n      }\n    }\n  }]);\n\n  return FixedDataTableRowBuffer;\n}();\n\nmodule.exports = FixedDataTableRowBuffer;","map":{"version":3,"sources":["C:/Versa/pagination/node_modules/fixed-data-table/internal/FixedDataTableRowBuffer.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","IntegerBufferSet","require","clamp","invariant","MIN_BUFFER_ROWS","MAX_BUFFER_ROWS","FixedDataTableRowBuffer","rowsCount","defaultRowHeight","viewportHeight","rowHeightGetter","_bufferSet","_defaultRowHeight","_viewportRowsBegin","_viewportRowsEnd","_maxVisibleRowCount","Math","ceil","_bufferRowsCount","floor","_rowsCount","_rowHeightGetter","_rows","_viewportHeight","getRows","bind","getRowsWithUpdatedBuffer","value","remainingBufferRows","bufferRowIndex","max","_addRowToBuffer","firstRowIndex","firstRowOffset","top","totalHeight","rowIndex","endIndex","min","firstViewportRowIndex","lastViewportRowIndex","rowPosition","getValuePosition","viewportRowsCount","allowedRowsCount","getSize","replaceFurthestValuePosition","getNewPositionForValue","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FixedDataTableRowBuffer\n * @typechecks\n */\n\n'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar IntegerBufferSet = require('./IntegerBufferSet');\n\nvar clamp = require('./clamp');\nvar invariant = require('./invariant');\nvar MIN_BUFFER_ROWS = 3;\nvar MAX_BUFFER_ROWS = 6;\n\n// FixedDataTableRowBuffer is a helper class that executes row buffering\n// logic for FixedDataTable. It figures out which rows should be rendered\n// and in which positions.\n\nvar FixedDataTableRowBuffer = (function () {\n  function FixedDataTableRowBuffer(\n  /*number*/rowsCount,\n  /*number*/defaultRowHeight,\n  /*number*/viewportHeight,\n  /*?function*/rowHeightGetter) {\n    _classCallCheck(this, FixedDataTableRowBuffer);\n\n    invariant(defaultRowHeight !== 0, \"defaultRowHeight musn't be equal 0 in FixedDataTableRowBuffer\");\n\n    this._bufferSet = new IntegerBufferSet();\n    this._defaultRowHeight = defaultRowHeight;\n    this._viewportRowsBegin = 0;\n    this._viewportRowsEnd = 0;\n    this._maxVisibleRowCount = Math.ceil(viewportHeight / defaultRowHeight) + 1;\n    this._bufferRowsCount = clamp(Math.floor(this._maxVisibleRowCount / 2), MIN_BUFFER_ROWS, MAX_BUFFER_ROWS);\n    this._rowsCount = rowsCount;\n    this._rowHeightGetter = rowHeightGetter;\n    this._rows = [];\n    this._viewportHeight = viewportHeight;\n\n    this.getRows = this.getRows.bind(this);\n    this.getRowsWithUpdatedBuffer = this.getRowsWithUpdatedBuffer.bind(this);\n  }\n\n  _createClass(FixedDataTableRowBuffer, [{\n    key: 'getRowsWithUpdatedBuffer',\n    value: function getRowsWithUpdatedBuffer() /*array*/{\n      var remainingBufferRows = 2 * this._bufferRowsCount;\n      var bufferRowIndex = Math.max(this._viewportRowsBegin - this._bufferRowsCount, 0);\n      while (bufferRowIndex < this._viewportRowsBegin) {\n        this._addRowToBuffer(bufferRowIndex, this._viewportRowsBegin, this._viewportRowsEnd - 1);\n        bufferRowIndex++;\n        remainingBufferRows--;\n      }\n      bufferRowIndex = this._viewportRowsEnd;\n      while (bufferRowIndex < this._rowsCount && remainingBufferRows > 0) {\n        this._addRowToBuffer(bufferRowIndex, this._viewportRowsBegin, this._viewportRowsEnd - 1);\n        bufferRowIndex++;\n        remainingBufferRows--;\n      }\n      return this._rows;\n    }\n  }, {\n    key: 'getRows',\n    value: function getRows(\n    /*number*/firstRowIndex,\n    /*number*/firstRowOffset) /*array*/{\n      var top = firstRowOffset;\n      var totalHeight = top;\n      var rowIndex = firstRowIndex;\n      var endIndex = Math.min(firstRowIndex + this._maxVisibleRowCount, this._rowsCount);\n\n      this._viewportRowsBegin = firstRowIndex;\n      while (rowIndex < endIndex || totalHeight < this._viewportHeight && rowIndex < this._rowsCount) {\n        this._addRowToBuffer(rowIndex, firstRowIndex, endIndex - 1);\n        totalHeight += this._rowHeightGetter(rowIndex);\n        ++rowIndex;\n        // Store index after the last viewport row as end, to be able to\n        // distinguish when there are no rows rendered in viewport\n        this._viewportRowsEnd = rowIndex;\n      }\n\n      return this._rows;\n    }\n  }, {\n    key: '_addRowToBuffer',\n    value: function _addRowToBuffer(\n    /*number*/rowIndex,\n    /*number*/firstViewportRowIndex,\n    /*number*/lastViewportRowIndex) {\n      var rowPosition = this._bufferSet.getValuePosition(rowIndex);\n      var viewportRowsCount = lastViewportRowIndex - firstViewportRowIndex + 1;\n      var allowedRowsCount = viewportRowsCount + this._bufferRowsCount * 2;\n      if (rowPosition === null && this._bufferSet.getSize() >= allowedRowsCount) {\n        rowPosition = this._bufferSet.replaceFurthestValuePosition(firstViewportRowIndex, lastViewportRowIndex, rowIndex);\n      }\n      if (rowPosition === null) {\n        // We can't reuse any of existing positions for this row. We have to\n        // create new position\n        rowPosition = this._bufferSet.getNewPositionForValue(rowIndex);\n        this._rows[rowPosition] = rowIndex;\n      } else {\n        // This row already is in the table with rowPosition position or it\n        // can replace row that is in that position\n        this._rows[rowPosition] = rowIndex;\n      }\n    }\n  }]);\n\n  return FixedDataTableRowBuffer;\n})();\n\nmodule.exports = FixedDataTableRowBuffer;"]},"metadata":{},"sourceType":"script"}