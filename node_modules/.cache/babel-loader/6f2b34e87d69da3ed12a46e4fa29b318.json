{"ast":null,"code":"/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule PrefixIntervalTree\n * \n * @typechecks\n */\n'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\n\nvar invariant = require('./invariant');\n\nvar parent = function parent(node) {\n  return Math.floor(node / 2);\n};\n\nvar Int32Array = global.Int32Array || function (size) {\n  var xs = [];\n\n  for (var i = size - 1; i >= 0; --i) {\n    xs[i] = 0;\n  }\n\n  return xs;\n};\n/**\n * Computes the next power of 2 after or equal to x.\n */\n\n\nfunction ceilLog2(x) {\n  var y = 1;\n\n  while (y < x) {\n    y *= 2;\n  }\n\n  return y;\n}\n/**\n * A prefix interval tree stores an numeric array and the partial sums of that\n * array. It is optimized for updating the values of the array without\n * recomputing all of the partial sums.\n *\n *   - O(ln n) update\n *   - O(1) lookup\n *   - O(ln n) compute a partial sum\n *   - O(n) space\n *\n * Note that the sequence of partial sums is one longer than the array, so that\n * the first partial sum is always 0, and the last partial sum is the sum of the\n * entire array.\n */\n\n\nvar PrefixIntervalTree = function () {\n  function PrefixIntervalTree(xs) {\n    _classCallCheck(this, PrefixIntervalTree);\n\n    this._size = xs.length;\n    this._half = ceilLog2(this._size);\n    this._heap = new Int32Array(2 * this._half);\n    var i;\n\n    for (i = 0; i < this._size; ++i) {\n      this._heap[this._half + i] = xs[i];\n    }\n\n    for (i = this._half - 1; i > 0; --i) {\n      this._heap[i] = this._heap[2 * i] + this._heap[2 * i + 1];\n    }\n  }\n\n  _createClass(PrefixIntervalTree, [{\n    key: 'set',\n    value: function set(index, value) {\n      invariant(0 <= index && index < this._size, 'Index out of range %s', index);\n      var node = this._half + index;\n      this._heap[node] = value;\n      node = parent(node);\n\n      for (; node !== 0; node = parent(node)) {\n        this._heap[node] = this._heap[2 * node] + this._heap[2 * node + 1];\n      }\n    }\n  }, {\n    key: 'get',\n    value: function get(index) {\n      invariant(0 <= index && index < this._size, 'Index out of range %s', index);\n      var node = this._half + index;\n      return this._heap[node];\n    }\n  }, {\n    key: 'getSize',\n    value: function getSize() {\n      return this._size;\n    }\n    /**\n     * Returns the sum get(0) + get(1) + ... + get(end - 1).\n     */\n\n  }, {\n    key: 'sumUntil',\n    value: function sumUntil(end) {\n      invariant(0 <= end && end < this._size + 1, 'Index out of range %s', end);\n\n      if (end === 0) {\n        return 0;\n      }\n\n      var node = this._half + end - 1;\n      var sum = this._heap[node];\n\n      for (; node !== 1; node = parent(node)) {\n        if (node % 2 === 1) {\n          sum += this._heap[node - 1];\n        }\n      }\n\n      return sum;\n    }\n    /**\n     * Returns the sum get(0) + get(1) + ... + get(inclusiveEnd).\n     */\n\n  }, {\n    key: 'sumTo',\n    value: function sumTo(inclusiveEnd) {\n      invariant(0 <= inclusiveEnd && inclusiveEnd < this._size, 'Index out of range %s', inclusiveEnd);\n      return this.sumUntil(inclusiveEnd + 1);\n    }\n    /**\n     * Returns the sum get(begin) + get(begin + 1) + ... + get(end - 1).\n     */\n\n  }, {\n    key: 'sum',\n    value: function sum(begin, end) {\n      invariant(begin <= end, 'Begin must precede end');\n      return this.sumUntil(end) - this.sumUntil(begin);\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) <= t, or\n     * -1 if no such i exists.\n     */\n\n  }, {\n    key: 'greatestLowerBound',\n    value: function greatestLowerBound(t) {\n      if (t < 0) {\n        return -1;\n      }\n\n      var node = 1;\n\n      if (this._heap[node] <= t) {\n        return this._size;\n      }\n\n      while (node < this._half) {\n        var leftSum = this._heap[2 * node];\n\n        if (t < leftSum) {\n          node = 2 * node;\n        } else {\n          node = 2 * node + 1;\n          t -= leftSum;\n        }\n      }\n\n      return node - this._half;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) < t, or\n     * -1 if no such i exists.\n     */\n\n  }, {\n    key: 'greatestStrictLowerBound',\n    value: function greatestStrictLowerBound(t) {\n      if (t <= 0) {\n        return -1;\n      }\n\n      var node = 1;\n\n      if (this._heap[node] < t) {\n        return this._size;\n      }\n\n      while (node < this._half) {\n        var leftSum = this._heap[2 * node];\n\n        if (t <= leftSum) {\n          node = 2 * node;\n        } else {\n          node = 2 * node + 1;\n          t -= leftSum;\n        }\n      }\n\n      return node - this._half;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and t <= sumUntil(i), or\n     * size + 1 if no such i exists.\n     */\n\n  }, {\n    key: 'leastUpperBound',\n    value: function leastUpperBound(t) {\n      return this.greatestStrictLowerBound(t) + 1;\n    }\n    /**\n     * Returns the smallest i such that 0 <= i <= size and t < sumUntil(i), or\n     * size + 1 if no such i exists.\n     */\n\n  }, {\n    key: 'leastStrictUpperBound',\n    value: function leastStrictUpperBound(t) {\n      return this.greatestLowerBound(t) + 1;\n    }\n  }], [{\n    key: 'uniform',\n    value: function uniform(size, initialValue) {\n      var xs = [];\n\n      for (var i = size - 1; i >= 0; --i) {\n        xs[i] = initialValue;\n      }\n\n      return new PrefixIntervalTree(xs);\n    }\n  }, {\n    key: 'empty',\n    value: function empty(size) {\n      return PrefixIntervalTree.uniform(size, 0);\n    }\n  }]);\n\n  return PrefixIntervalTree;\n}();\n\nmodule.exports = PrefixIntervalTree;\n/**\n * Number of elements in the array\n */\n\n/**\n * Half the size of the heap. It is also the number of non-leaf nodes, and the\n * index of the first element in the heap. Always a power of 2.\n */\n\n/**\n * Binary heap\n */","map":{"version":3,"sources":["C:/Versa/pagination/node_modules/fixed-data-table/internal/PrefixIntervalTree.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","invariant","require","parent","node","Math","floor","Int32Array","global","size","xs","ceilLog2","x","y","PrefixIntervalTree","_size","_half","_heap","value","set","index","get","getSize","sumUntil","end","sum","sumTo","inclusiveEnd","begin","greatestLowerBound","t","leftSum","greatestStrictLowerBound","leastUpperBound","leastStrictUpperBound","uniform","initialValue","empty","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule PrefixIntervalTree\n * \n * @typechecks\n */\n\n'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar invariant = require('./invariant');\n\nvar parent = function parent(node) {\n  return Math.floor(node / 2);\n};\n\nvar Int32Array = global.Int32Array || function (size) {\n  var xs = [];\n  for (var i = size - 1; i >= 0; --i) {\n    xs[i] = 0;\n  }\n  return xs;\n};\n\n/**\n * Computes the next power of 2 after or equal to x.\n */\nfunction ceilLog2(x) {\n  var y = 1;\n  while (y < x) {\n    y *= 2;\n  }\n  return y;\n}\n\n/**\n * A prefix interval tree stores an numeric array and the partial sums of that\n * array. It is optimized for updating the values of the array without\n * recomputing all of the partial sums.\n *\n *   - O(ln n) update\n *   - O(1) lookup\n *   - O(ln n) compute a partial sum\n *   - O(n) space\n *\n * Note that the sequence of partial sums is one longer than the array, so that\n * the first partial sum is always 0, and the last partial sum is the sum of the\n * entire array.\n */\n\nvar PrefixIntervalTree = (function () {\n  function PrefixIntervalTree(xs) {\n    _classCallCheck(this, PrefixIntervalTree);\n\n    this._size = xs.length;\n    this._half = ceilLog2(this._size);\n    this._heap = new Int32Array(2 * this._half);\n\n    var i;\n    for (i = 0; i < this._size; ++i) {\n      this._heap[this._half + i] = xs[i];\n    }\n\n    for (i = this._half - 1; i > 0; --i) {\n      this._heap[i] = this._heap[2 * i] + this._heap[2 * i + 1];\n    }\n  }\n\n  _createClass(PrefixIntervalTree, [{\n    key: 'set',\n    value: function set(index, value) {\n      invariant(0 <= index && index < this._size, 'Index out of range %s', index);\n\n      var node = this._half + index;\n      this._heap[node] = value;\n\n      node = parent(node);\n      for (; node !== 0; node = parent(node)) {\n        this._heap[node] = this._heap[2 * node] + this._heap[2 * node + 1];\n      }\n    }\n  }, {\n    key: 'get',\n    value: function get(index) {\n      invariant(0 <= index && index < this._size, 'Index out of range %s', index);\n\n      var node = this._half + index;\n      return this._heap[node];\n    }\n  }, {\n    key: 'getSize',\n    value: function getSize() {\n      return this._size;\n    }\n\n    /**\n     * Returns the sum get(0) + get(1) + ... + get(end - 1).\n     */\n  }, {\n    key: 'sumUntil',\n    value: function sumUntil(end) {\n      invariant(0 <= end && end < this._size + 1, 'Index out of range %s', end);\n\n      if (end === 0) {\n        return 0;\n      }\n\n      var node = this._half + end - 1;\n      var sum = this._heap[node];\n      for (; node !== 1; node = parent(node)) {\n        if (node % 2 === 1) {\n          sum += this._heap[node - 1];\n        }\n      }\n\n      return sum;\n    }\n\n    /**\n     * Returns the sum get(0) + get(1) + ... + get(inclusiveEnd).\n     */\n  }, {\n    key: 'sumTo',\n    value: function sumTo(inclusiveEnd) {\n      invariant(0 <= inclusiveEnd && inclusiveEnd < this._size, 'Index out of range %s', inclusiveEnd);\n      return this.sumUntil(inclusiveEnd + 1);\n    }\n\n    /**\n     * Returns the sum get(begin) + get(begin + 1) + ... + get(end - 1).\n     */\n  }, {\n    key: 'sum',\n    value: function sum(begin, end) {\n      invariant(begin <= end, 'Begin must precede end');\n      return this.sumUntil(end) - this.sumUntil(begin);\n    }\n\n    /**\n     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) <= t, or\n     * -1 if no such i exists.\n     */\n  }, {\n    key: 'greatestLowerBound',\n    value: function greatestLowerBound(t) {\n      if (t < 0) {\n        return -1;\n      }\n\n      var node = 1;\n      if (this._heap[node] <= t) {\n        return this._size;\n      }\n\n      while (node < this._half) {\n        var leftSum = this._heap[2 * node];\n        if (t < leftSum) {\n          node = 2 * node;\n        } else {\n          node = 2 * node + 1;\n          t -= leftSum;\n        }\n      }\n\n      return node - this._half;\n    }\n\n    /**\n     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) < t, or\n     * -1 if no such i exists.\n     */\n  }, {\n    key: 'greatestStrictLowerBound',\n    value: function greatestStrictLowerBound(t) {\n      if (t <= 0) {\n        return -1;\n      }\n\n      var node = 1;\n      if (this._heap[node] < t) {\n        return this._size;\n      }\n\n      while (node < this._half) {\n        var leftSum = this._heap[2 * node];\n        if (t <= leftSum) {\n          node = 2 * node;\n        } else {\n          node = 2 * node + 1;\n          t -= leftSum;\n        }\n      }\n\n      return node - this._half;\n    }\n\n    /**\n     * Returns the smallest i such that 0 <= i <= size and t <= sumUntil(i), or\n     * size + 1 if no such i exists.\n     */\n  }, {\n    key: 'leastUpperBound',\n    value: function leastUpperBound(t) {\n      return this.greatestStrictLowerBound(t) + 1;\n    }\n\n    /**\n     * Returns the smallest i such that 0 <= i <= size and t < sumUntil(i), or\n     * size + 1 if no such i exists.\n     */\n  }, {\n    key: 'leastStrictUpperBound',\n    value: function leastStrictUpperBound(t) {\n      return this.greatestLowerBound(t) + 1;\n    }\n  }], [{\n    key: 'uniform',\n    value: function uniform(size, initialValue) {\n      var xs = [];\n      for (var i = size - 1; i >= 0; --i) {\n        xs[i] = initialValue;\n      }\n\n      return new PrefixIntervalTree(xs);\n    }\n  }, {\n    key: 'empty',\n    value: function empty(size) {\n      return PrefixIntervalTree.uniform(size, 0);\n    }\n  }]);\n\n  return PrefixIntervalTree;\n})();\n\nmodule.exports = PrefixIntervalTree;\n\n/**\n * Number of elements in the array\n */\n\n/**\n * Half the size of the heap. It is also the number of non-leaf nodes, and the\n * index of the first element in the heap. Always a power of 2.\n */\n\n/**\n * Binary heap\n */"]},"metadata":{},"sourceType":"script"}