{"ast":null,"code":"/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FixedDataTableScrollHelper\n * @typechecks\n */\n'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\n\nvar PrefixIntervalTree = require('./PrefixIntervalTree');\n\nvar clamp = require('./clamp');\n\nvar BUFFER_ROWS = 5;\nvar NO_ROWS_SCROLL_RESULT = {\n  index: 0,\n  offset: 0,\n  position: 0,\n  contentHeight: 0\n};\n\nvar FixedDataTableScrollHelper = function () {\n  function FixedDataTableScrollHelper(\n  /*number*/\n  rowCount,\n  /*number*/\n  defaultRowHeight,\n  /*number*/\n  viewportHeight,\n  /*?function*/\n  rowHeightGetter) {\n    _classCallCheck(this, FixedDataTableScrollHelper);\n\n    this._rowOffsets = PrefixIntervalTree.uniform(rowCount, defaultRowHeight);\n    this._storedHeights = new Array(rowCount);\n\n    for (var i = 0; i < rowCount; ++i) {\n      this._storedHeights[i] = defaultRowHeight;\n    }\n\n    this._rowCount = rowCount;\n    this._position = 0;\n    this._contentHeight = rowCount * defaultRowHeight;\n    this._defaultRowHeight = defaultRowHeight;\n    this._rowHeightGetter = rowHeightGetter ? rowHeightGetter : function () {\n      return defaultRowHeight;\n    };\n    this._viewportHeight = viewportHeight;\n    this.scrollRowIntoView = this.scrollRowIntoView.bind(this);\n    this.setViewportHeight = this.setViewportHeight.bind(this);\n    this.scrollBy = this.scrollBy.bind(this);\n    this.scrollTo = this.scrollTo.bind(this);\n    this.scrollToRow = this.scrollToRow.bind(this);\n    this.setRowHeightGetter = this.setRowHeightGetter.bind(this);\n    this.getContentHeight = this.getContentHeight.bind(this);\n    this.getRowPosition = this.getRowPosition.bind(this);\n\n    this._updateHeightsInViewport(0, 0);\n  }\n\n  _createClass(FixedDataTableScrollHelper, [{\n    key: 'setRowHeightGetter',\n    value: function setRowHeightGetter(\n    /*function*/\n    rowHeightGetter) {\n      this._rowHeightGetter = rowHeightGetter;\n    }\n  }, {\n    key: 'setViewportHeight',\n    value: function setViewportHeight(\n    /*number*/\n    viewportHeight) {\n      this._viewportHeight = viewportHeight;\n    }\n  }, {\n    key: 'getContentHeight',\n    value: function getContentHeight()\n    /*number*/\n    {\n      return this._contentHeight;\n    }\n  }, {\n    key: '_updateHeightsInViewport',\n    value: function _updateHeightsInViewport(\n    /*number*/\n    firstRowIndex,\n    /*number*/\n    firstRowOffset) {\n      var top = firstRowOffset;\n      var index = firstRowIndex;\n\n      while (top <= this._viewportHeight && index < this._rowCount) {\n        this._updateRowHeight(index);\n\n        top += this._storedHeights[index];\n        index++;\n      }\n    }\n  }, {\n    key: '_updateHeightsAboveViewport',\n    value: function _updateHeightsAboveViewport(\n    /*number*/\n    firstRowIndex) {\n      var index = firstRowIndex - 1;\n\n      while (index >= 0 && index >= firstRowIndex - BUFFER_ROWS) {\n        var delta = this._updateRowHeight(index);\n\n        this._position += delta;\n        index--;\n      }\n    }\n  }, {\n    key: '_updateRowHeight',\n    value: function _updateRowHeight(\n    /*number*/\n    rowIndex)\n    /*number*/\n    {\n      if (rowIndex < 0 || rowIndex >= this._rowCount) {\n        return 0;\n      }\n\n      var newHeight = this._rowHeightGetter(rowIndex);\n\n      if (newHeight !== this._storedHeights[rowIndex]) {\n        var change = newHeight - this._storedHeights[rowIndex];\n\n        this._rowOffsets.set(rowIndex, newHeight);\n\n        this._storedHeights[rowIndex] = newHeight;\n        this._contentHeight += change;\n        return change;\n      }\n\n      return 0;\n    }\n  }, {\n    key: 'getRowPosition',\n    value: function getRowPosition(\n    /*number*/\n    rowIndex)\n    /*number*/\n    {\n      this._updateRowHeight(rowIndex);\n\n      return this._rowOffsets.sumUntil(rowIndex);\n    }\n  }, {\n    key: 'scrollBy',\n    value: function scrollBy(\n    /*number*/\n    delta)\n    /*object*/\n    {\n      if (this._rowCount === 0) {\n        return NO_ROWS_SCROLL_RESULT;\n      }\n\n      var firstRow = this._rowOffsets.greatestLowerBound(this._position);\n\n      firstRow = clamp(firstRow, 0, Math.max(this._rowCount - 1, 0));\n\n      var firstRowPosition = this._rowOffsets.sumUntil(firstRow);\n\n      var rowIndex = firstRow;\n      var position = this._position;\n\n      var rowHeightChange = this._updateRowHeight(rowIndex);\n\n      if (firstRowPosition !== 0) {\n        position += rowHeightChange;\n      }\n\n      var visibleRowHeight = this._storedHeights[rowIndex] - (position - firstRowPosition);\n\n      if (delta >= 0) {\n        while (delta > 0 && rowIndex < this._rowCount) {\n          if (delta < visibleRowHeight) {\n            position += delta;\n            delta = 0;\n          } else {\n            delta -= visibleRowHeight;\n            position += visibleRowHeight;\n            rowIndex++;\n          }\n\n          if (rowIndex < this._rowCount) {\n            this._updateRowHeight(rowIndex);\n\n            visibleRowHeight = this._storedHeights[rowIndex];\n          }\n        }\n      } else if (delta < 0) {\n        delta = -delta;\n        var invisibleRowHeight = this._storedHeights[rowIndex] - visibleRowHeight;\n\n        while (delta > 0 && rowIndex >= 0) {\n          if (delta < invisibleRowHeight) {\n            position -= delta;\n            delta = 0;\n          } else {\n            position -= invisibleRowHeight;\n            delta -= invisibleRowHeight;\n            rowIndex--;\n          }\n\n          if (rowIndex >= 0) {\n            var change = this._updateRowHeight(rowIndex);\n\n            invisibleRowHeight = this._storedHeights[rowIndex];\n            position += change;\n          }\n        }\n      }\n\n      var maxPosition = this._contentHeight - this._viewportHeight;\n      position = clamp(position, 0, maxPosition);\n      this._position = position;\n\n      var firstRowIndex = this._rowOffsets.greatestLowerBound(position);\n\n      firstRowIndex = clamp(firstRowIndex, 0, Math.max(this._rowCount - 1, 0));\n      firstRowPosition = this._rowOffsets.sumUntil(firstRowIndex);\n      var firstRowOffset = firstRowPosition - position;\n\n      this._updateHeightsInViewport(firstRowIndex, firstRowOffset);\n\n      this._updateHeightsAboveViewport(firstRowIndex);\n\n      return {\n        index: firstRowIndex,\n        offset: firstRowOffset,\n        position: this._position,\n        contentHeight: this._contentHeight\n      };\n    }\n  }, {\n    key: '_getRowAtEndPosition',\n    value: function _getRowAtEndPosition(\n    /*number*/\n    rowIndex)\n    /*number*/\n    {\n      // We need to update enough rows above the selected one to be sure that when\n      // we scroll to selected position all rows between first shown and selected\n      // one have most recent heights computed and will not resize\n      this._updateRowHeight(rowIndex);\n\n      var currentRowIndex = rowIndex;\n      var top = this._storedHeights[currentRowIndex];\n\n      while (top < this._viewportHeight && currentRowIndex >= 0) {\n        currentRowIndex--;\n\n        if (currentRowIndex >= 0) {\n          this._updateRowHeight(currentRowIndex);\n\n          top += this._storedHeights[currentRowIndex];\n        }\n      }\n\n      var position = this._rowOffsets.sumTo(rowIndex) - this._viewportHeight;\n\n      if (position < 0) {\n        position = 0;\n      }\n\n      return position;\n    }\n  }, {\n    key: 'scrollTo',\n    value: function scrollTo(\n    /*number*/\n    position)\n    /*object*/\n    {\n      if (this._rowCount === 0) {\n        return NO_ROWS_SCROLL_RESULT;\n      }\n\n      if (position <= 0) {\n        // If position less than or equal to 0 first row should be fully visible\n        // on top\n        this._position = 0;\n\n        this._updateHeightsInViewport(0, 0);\n\n        return {\n          index: 0,\n          offset: 0,\n          position: this._position,\n          contentHeight: this._contentHeight\n        };\n      } else if (position >= this._contentHeight - this._viewportHeight) {\n        // If position is equal to or greater than max scroll value, we need\n        // to make sure to have bottom border of last row visible.\n        var rowIndex = this._rowCount - 1;\n        position = this._getRowAtEndPosition(rowIndex);\n      }\n\n      this._position = position;\n\n      var firstRowIndex = this._rowOffsets.greatestLowerBound(position);\n\n      firstRowIndex = clamp(firstRowIndex, 0, Math.max(this._rowCount - 1, 0));\n\n      var firstRowPosition = this._rowOffsets.sumUntil(firstRowIndex);\n\n      var firstRowOffset = firstRowPosition - position;\n\n      this._updateHeightsInViewport(firstRowIndex, firstRowOffset);\n\n      this._updateHeightsAboveViewport(firstRowIndex);\n\n      return {\n        index: firstRowIndex,\n        offset: firstRowOffset,\n        position: this._position,\n        contentHeight: this._contentHeight\n      };\n    }\n    /**\n     * Allows to scroll to selected row with specified offset. It always\n     * brings that row to top of viewport with that offset\n     */\n\n  }, {\n    key: 'scrollToRow',\n    value: function scrollToRow(\n    /*number*/\n    rowIndex,\n    /*number*/\n    offset)\n    /*object*/\n    {\n      rowIndex = clamp(rowIndex, 0, Math.max(this._rowCount - 1, 0));\n      offset = clamp(offset, -this._storedHeights[rowIndex], 0);\n\n      var firstRow = this._rowOffsets.sumUntil(rowIndex);\n\n      return this.scrollTo(firstRow - offset);\n    }\n    /**\n     * Allows to scroll to selected row by bringing it to viewport with minimal\n     * scrolling. This that if row is fully visible, scroll will not be changed.\n     * If top border of row is above top of viewport it will be scrolled to be\n     * fully visible on the top of viewport. If the bottom border of row is\n     * below end of viewport, it will be scrolled up to be fully visible on the\n     * bottom of viewport.\n     */\n\n  }, {\n    key: 'scrollRowIntoView',\n    value: function scrollRowIntoView(\n    /*number*/\n    rowIndex)\n    /*object*/\n    {\n      rowIndex = clamp(rowIndex, 0, Math.max(this._rowCount - 1, 0));\n\n      var rowBegin = this._rowOffsets.sumUntil(rowIndex);\n\n      var rowEnd = rowBegin + this._storedHeights[rowIndex];\n\n      if (rowBegin < this._position) {\n        return this.scrollTo(rowBegin);\n      } else if (this._position + this._viewportHeight < rowEnd) {\n        var position = this._getRowAtEndPosition(rowIndex);\n\n        return this.scrollTo(position);\n      }\n\n      return this.scrollTo(this._position);\n    }\n  }]);\n\n  return FixedDataTableScrollHelper;\n}();\n\nmodule.exports = FixedDataTableScrollHelper;","map":{"version":3,"sources":["C:/Versa/pagination/node_modules/fixed-data-table/internal/FixedDataTableScrollHelper.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","PrefixIntervalTree","require","clamp","BUFFER_ROWS","NO_ROWS_SCROLL_RESULT","index","offset","position","contentHeight","FixedDataTableScrollHelper","rowCount","defaultRowHeight","viewportHeight","rowHeightGetter","_rowOffsets","uniform","_storedHeights","Array","_rowCount","_position","_contentHeight","_defaultRowHeight","_rowHeightGetter","_viewportHeight","scrollRowIntoView","bind","setViewportHeight","scrollBy","scrollTo","scrollToRow","setRowHeightGetter","getContentHeight","getRowPosition","_updateHeightsInViewport","value","firstRowIndex","firstRowOffset","top","_updateRowHeight","_updateHeightsAboveViewport","delta","rowIndex","newHeight","change","set","sumUntil","firstRow","greatestLowerBound","Math","max","firstRowPosition","rowHeightChange","visibleRowHeight","invisibleRowHeight","maxPosition","_getRowAtEndPosition","currentRowIndex","sumTo","rowBegin","rowEnd","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule FixedDataTableScrollHelper\n * @typechecks\n */\n\n'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar PrefixIntervalTree = require('./PrefixIntervalTree');\nvar clamp = require('./clamp');\n\nvar BUFFER_ROWS = 5;\nvar NO_ROWS_SCROLL_RESULT = {\n  index: 0,\n  offset: 0,\n  position: 0,\n  contentHeight: 0\n};\n\nvar FixedDataTableScrollHelper = (function () {\n  function FixedDataTableScrollHelper(\n  /*number*/rowCount,\n  /*number*/defaultRowHeight,\n  /*number*/viewportHeight,\n  /*?function*/rowHeightGetter) {\n    _classCallCheck(this, FixedDataTableScrollHelper);\n\n    this._rowOffsets = PrefixIntervalTree.uniform(rowCount, defaultRowHeight);\n    this._storedHeights = new Array(rowCount);\n    for (var i = 0; i < rowCount; ++i) {\n      this._storedHeights[i] = defaultRowHeight;\n    }\n    this._rowCount = rowCount;\n    this._position = 0;\n    this._contentHeight = rowCount * defaultRowHeight;\n    this._defaultRowHeight = defaultRowHeight;\n    this._rowHeightGetter = rowHeightGetter ? rowHeightGetter : function () {\n      return defaultRowHeight;\n    };\n    this._viewportHeight = viewportHeight;\n    this.scrollRowIntoView = this.scrollRowIntoView.bind(this);\n    this.setViewportHeight = this.setViewportHeight.bind(this);\n    this.scrollBy = this.scrollBy.bind(this);\n    this.scrollTo = this.scrollTo.bind(this);\n    this.scrollToRow = this.scrollToRow.bind(this);\n    this.setRowHeightGetter = this.setRowHeightGetter.bind(this);\n    this.getContentHeight = this.getContentHeight.bind(this);\n    this.getRowPosition = this.getRowPosition.bind(this);\n\n    this._updateHeightsInViewport(0, 0);\n  }\n\n  _createClass(FixedDataTableScrollHelper, [{\n    key: 'setRowHeightGetter',\n    value: function setRowHeightGetter( /*function*/rowHeightGetter) {\n      this._rowHeightGetter = rowHeightGetter;\n    }\n  }, {\n    key: 'setViewportHeight',\n    value: function setViewportHeight( /*number*/viewportHeight) {\n      this._viewportHeight = viewportHeight;\n    }\n  }, {\n    key: 'getContentHeight',\n    value: function getContentHeight() /*number*/{\n      return this._contentHeight;\n    }\n  }, {\n    key: '_updateHeightsInViewport',\n    value: function _updateHeightsInViewport(\n    /*number*/firstRowIndex,\n    /*number*/firstRowOffset) {\n      var top = firstRowOffset;\n      var index = firstRowIndex;\n      while (top <= this._viewportHeight && index < this._rowCount) {\n        this._updateRowHeight(index);\n        top += this._storedHeights[index];\n        index++;\n      }\n    }\n  }, {\n    key: '_updateHeightsAboveViewport',\n    value: function _updateHeightsAboveViewport( /*number*/firstRowIndex) {\n      var index = firstRowIndex - 1;\n      while (index >= 0 && index >= firstRowIndex - BUFFER_ROWS) {\n        var delta = this._updateRowHeight(index);\n        this._position += delta;\n        index--;\n      }\n    }\n  }, {\n    key: '_updateRowHeight',\n    value: function _updateRowHeight( /*number*/rowIndex) /*number*/{\n      if (rowIndex < 0 || rowIndex >= this._rowCount) {\n        return 0;\n      }\n      var newHeight = this._rowHeightGetter(rowIndex);\n      if (newHeight !== this._storedHeights[rowIndex]) {\n        var change = newHeight - this._storedHeights[rowIndex];\n        this._rowOffsets.set(rowIndex, newHeight);\n        this._storedHeights[rowIndex] = newHeight;\n        this._contentHeight += change;\n        return change;\n      }\n      return 0;\n    }\n  }, {\n    key: 'getRowPosition',\n    value: function getRowPosition( /*number*/rowIndex) /*number*/{\n      this._updateRowHeight(rowIndex);\n      return this._rowOffsets.sumUntil(rowIndex);\n    }\n  }, {\n    key: 'scrollBy',\n    value: function scrollBy( /*number*/delta) /*object*/{\n      if (this._rowCount === 0) {\n        return NO_ROWS_SCROLL_RESULT;\n      }\n      var firstRow = this._rowOffsets.greatestLowerBound(this._position);\n      firstRow = clamp(firstRow, 0, Math.max(this._rowCount - 1, 0));\n      var firstRowPosition = this._rowOffsets.sumUntil(firstRow);\n      var rowIndex = firstRow;\n      var position = this._position;\n\n      var rowHeightChange = this._updateRowHeight(rowIndex);\n      if (firstRowPosition !== 0) {\n        position += rowHeightChange;\n      }\n      var visibleRowHeight = this._storedHeights[rowIndex] - (position - firstRowPosition);\n\n      if (delta >= 0) {\n\n        while (delta > 0 && rowIndex < this._rowCount) {\n          if (delta < visibleRowHeight) {\n            position += delta;\n            delta = 0;\n          } else {\n            delta -= visibleRowHeight;\n            position += visibleRowHeight;\n            rowIndex++;\n          }\n          if (rowIndex < this._rowCount) {\n            this._updateRowHeight(rowIndex);\n            visibleRowHeight = this._storedHeights[rowIndex];\n          }\n        }\n      } else if (delta < 0) {\n        delta = -delta;\n        var invisibleRowHeight = this._storedHeights[rowIndex] - visibleRowHeight;\n\n        while (delta > 0 && rowIndex >= 0) {\n          if (delta < invisibleRowHeight) {\n            position -= delta;\n            delta = 0;\n          } else {\n            position -= invisibleRowHeight;\n            delta -= invisibleRowHeight;\n            rowIndex--;\n          }\n          if (rowIndex >= 0) {\n            var change = this._updateRowHeight(rowIndex);\n            invisibleRowHeight = this._storedHeights[rowIndex];\n            position += change;\n          }\n        }\n      }\n\n      var maxPosition = this._contentHeight - this._viewportHeight;\n      position = clamp(position, 0, maxPosition);\n      this._position = position;\n      var firstRowIndex = this._rowOffsets.greatestLowerBound(position);\n      firstRowIndex = clamp(firstRowIndex, 0, Math.max(this._rowCount - 1, 0));\n      firstRowPosition = this._rowOffsets.sumUntil(firstRowIndex);\n      var firstRowOffset = firstRowPosition - position;\n\n      this._updateHeightsInViewport(firstRowIndex, firstRowOffset);\n      this._updateHeightsAboveViewport(firstRowIndex);\n\n      return {\n        index: firstRowIndex,\n        offset: firstRowOffset,\n        position: this._position,\n        contentHeight: this._contentHeight\n      };\n    }\n  }, {\n    key: '_getRowAtEndPosition',\n    value: function _getRowAtEndPosition( /*number*/rowIndex) /*number*/{\n      // We need to update enough rows above the selected one to be sure that when\n      // we scroll to selected position all rows between first shown and selected\n      // one have most recent heights computed and will not resize\n      this._updateRowHeight(rowIndex);\n      var currentRowIndex = rowIndex;\n      var top = this._storedHeights[currentRowIndex];\n      while (top < this._viewportHeight && currentRowIndex >= 0) {\n        currentRowIndex--;\n        if (currentRowIndex >= 0) {\n          this._updateRowHeight(currentRowIndex);\n          top += this._storedHeights[currentRowIndex];\n        }\n      }\n      var position = this._rowOffsets.sumTo(rowIndex) - this._viewportHeight;\n      if (position < 0) {\n        position = 0;\n      }\n      return position;\n    }\n  }, {\n    key: 'scrollTo',\n    value: function scrollTo( /*number*/position) /*object*/{\n      if (this._rowCount === 0) {\n        return NO_ROWS_SCROLL_RESULT;\n      }\n      if (position <= 0) {\n        // If position less than or equal to 0 first row should be fully visible\n        // on top\n        this._position = 0;\n        this._updateHeightsInViewport(0, 0);\n\n        return {\n          index: 0,\n          offset: 0,\n          position: this._position,\n          contentHeight: this._contentHeight\n        };\n      } else if (position >= this._contentHeight - this._viewportHeight) {\n        // If position is equal to or greater than max scroll value, we need\n        // to make sure to have bottom border of last row visible.\n        var rowIndex = this._rowCount - 1;\n        position = this._getRowAtEndPosition(rowIndex);\n      }\n      this._position = position;\n\n      var firstRowIndex = this._rowOffsets.greatestLowerBound(position);\n      firstRowIndex = clamp(firstRowIndex, 0, Math.max(this._rowCount - 1, 0));\n      var firstRowPosition = this._rowOffsets.sumUntil(firstRowIndex);\n      var firstRowOffset = firstRowPosition - position;\n\n      this._updateHeightsInViewport(firstRowIndex, firstRowOffset);\n      this._updateHeightsAboveViewport(firstRowIndex);\n\n      return {\n        index: firstRowIndex,\n        offset: firstRowOffset,\n        position: this._position,\n        contentHeight: this._contentHeight\n      };\n    }\n\n    /**\n     * Allows to scroll to selected row with specified offset. It always\n     * brings that row to top of viewport with that offset\n     */\n  }, {\n    key: 'scrollToRow',\n    value: function scrollToRow( /*number*/rowIndex, /*number*/offset) /*object*/{\n      rowIndex = clamp(rowIndex, 0, Math.max(this._rowCount - 1, 0));\n      offset = clamp(offset, -this._storedHeights[rowIndex], 0);\n      var firstRow = this._rowOffsets.sumUntil(rowIndex);\n      return this.scrollTo(firstRow - offset);\n    }\n\n    /**\n     * Allows to scroll to selected row by bringing it to viewport with minimal\n     * scrolling. This that if row is fully visible, scroll will not be changed.\n     * If top border of row is above top of viewport it will be scrolled to be\n     * fully visible on the top of viewport. If the bottom border of row is\n     * below end of viewport, it will be scrolled up to be fully visible on the\n     * bottom of viewport.\n     */\n  }, {\n    key: 'scrollRowIntoView',\n    value: function scrollRowIntoView( /*number*/rowIndex) /*object*/{\n      rowIndex = clamp(rowIndex, 0, Math.max(this._rowCount - 1, 0));\n      var rowBegin = this._rowOffsets.sumUntil(rowIndex);\n      var rowEnd = rowBegin + this._storedHeights[rowIndex];\n      if (rowBegin < this._position) {\n        return this.scrollTo(rowBegin);\n      } else if (this._position + this._viewportHeight < rowEnd) {\n        var position = this._getRowAtEndPosition(rowIndex);\n        return this.scrollTo(position);\n      }\n      return this.scrollTo(this._position);\n    }\n  }]);\n\n  return FixedDataTableScrollHelper;\n})();\n\nmodule.exports = FixedDataTableScrollHelper;"]},"metadata":{},"sourceType":"script"}