{"ast":null,"code":"/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule IntegerBufferSet\n * @typechecks\n */\n'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ('value' in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\n\nvar Heap = require('./Heap');\n\nvar invariant = require('./invariant'); // Data structure that allows to store values and assign positions to them\n// in a way to minimize changing positions of stored values when new ones are\n// added or when some values are replaced. Stored elements are alwasy assigned\n// a consecutive set of positoins startin from 0 up to count of elements less 1\n// Following actions can be executed\n// * get position assigned to given value (null if value is not stored)\n// * create new entry for new value and get assigned position back\n// * replace value that is furthest from specified value range with new value\n//   and get it's position back\n// All operations take amortized log(n) time where n is number of elements in\n// the set.\n\n\nvar IntegerBufferSet = function () {\n  function IntegerBufferSet() {\n    _classCallCheck(this, IntegerBufferSet);\n\n    this._valueToPositionMap = {};\n    this._size = 0;\n    this._smallValues = new Heap([], // Initial data in the heap\n    this._smallerComparator);\n    this._largeValues = new Heap([], // Initial data in the heap\n    this._greaterComparator);\n    this.getNewPositionForValue = this.getNewPositionForValue.bind(this);\n    this.getValuePosition = this.getValuePosition.bind(this);\n    this.getSize = this.getSize.bind(this);\n    this.replaceFurthestValuePosition = this.replaceFurthestValuePosition.bind(this);\n  }\n\n  _createClass(IntegerBufferSet, [{\n    key: 'getSize',\n    value: function getSize()\n    /*number*/\n    {\n      return this._size;\n    }\n  }, {\n    key: 'getValuePosition',\n    value: function getValuePosition(\n    /*number*/\n    value)\n    /*?number*/\n    {\n      if (this._valueToPositionMap[value] === undefined) {\n        return null;\n      }\n\n      return this._valueToPositionMap[value];\n    }\n  }, {\n    key: 'getNewPositionForValue',\n    value: function getNewPositionForValue(\n    /*number*/\n    value)\n    /*number*/\n    {\n      invariant(this._valueToPositionMap[value] === undefined, \"Shouldn't try to find new position for value already stored in BufferSet\");\n      var newPosition = this._size;\n      this._size++;\n\n      this._pushToHeaps(newPosition, value);\n\n      this._valueToPositionMap[value] = newPosition;\n      return newPosition;\n    }\n  }, {\n    key: 'replaceFurthestValuePosition',\n    value: function replaceFurthestValuePosition(\n    /*number*/\n    lowValue,\n    /*number*/\n    highValue,\n    /*number*/\n    newValue)\n    /*?number*/\n    {\n      invariant(this._valueToPositionMap[newValue] === undefined, \"Shouldn't try to replace values with value already stored value in \" + \"BufferSet\");\n\n      this._cleanHeaps();\n\n      if (this._smallValues.empty() || this._largeValues.empty()) {\n        // Threre are currently no values stored. We will have to create new\n        // position for this value.\n        return null;\n      }\n\n      var minValue = this._smallValues.peek().value;\n\n      var maxValue = this._largeValues.peek().value;\n\n      if (minValue >= lowValue && maxValue <= highValue) {\n        // All values currently stored are necessary, we can't reuse any of them.\n        return null;\n      }\n\n      var valueToReplace;\n\n      if (lowValue - minValue > maxValue - highValue) {\n        // minValue is further from provided range. We will reuse it's position.\n        valueToReplace = minValue;\n\n        this._smallValues.pop();\n      } else {\n        valueToReplace = maxValue;\n\n        this._largeValues.pop();\n      }\n\n      var position = this._valueToPositionMap[valueToReplace];\n      delete this._valueToPositionMap[valueToReplace];\n      this._valueToPositionMap[newValue] = position;\n\n      this._pushToHeaps(position, newValue);\n\n      return position;\n    }\n  }, {\n    key: '_pushToHeaps',\n    value: function _pushToHeaps(\n    /*number*/\n    position,\n    /*number*/\n    value) {\n      var element = {\n        position: position,\n        value: value\n      }; // We can reuse the same object in both heaps, because we don't mutate them\n\n      this._smallValues.push(element);\n\n      this._largeValues.push(element);\n    }\n  }, {\n    key: '_cleanHeaps',\n    value: function _cleanHeaps() {\n      // We not usually only remove object from one heap while moving value.\n      // Here we make sure that there is no stale data on top of heaps.\n      this._cleanHeap(this._smallValues);\n\n      this._cleanHeap(this._largeValues);\n\n      var minHeapSize = Math.min(this._smallValues.size(), this._largeValues.size());\n      var maxHeapSize = Math.max(this._smallValues.size(), this._largeValues.size());\n\n      if (maxHeapSize > 10 * minHeapSize) {\n        // There are many old values in one of heaps. We nned to get rid of them\n        // to not use too avoid memory leaks\n        this._recreateHeaps();\n      }\n    }\n  }, {\n    key: '_recreateHeaps',\n    value: function _recreateHeaps() {\n      var sourceHeap = this._smallValues.size() < this._largeValues.size() ? this._smallValues : this._largeValues;\n      var newSmallValues = new Heap([], // Initial data in the heap\n      this._smallerComparator);\n      var newLargeValues = new Heap([], // Initial datat in the heap\n      this._greaterComparator);\n\n      while (!sourceHeap.empty()) {\n        var element = sourceHeap.pop(); // Push all stil valid elements to new heaps\n\n        if (this._valueToPositionMap[element.value] !== undefined) {\n          newSmallValues.push(element);\n          newLargeValues.push(element);\n        }\n      }\n\n      this._smallValues = newSmallValues;\n      this._largeValues = newLargeValues;\n    }\n  }, {\n    key: '_cleanHeap',\n    value: function _cleanHeap(\n    /*object*/\n    heap) {\n      while (!heap.empty() && this._valueToPositionMap[heap.peek().value] === undefined) {\n        heap.pop();\n      }\n    }\n  }, {\n    key: '_smallerComparator',\n    value: function _smallerComparator(\n    /*object*/\n    lhs,\n    /*object*/\n    rhs)\n    /*boolean*/\n    {\n      return lhs.value < rhs.value;\n    }\n  }, {\n    key: '_greaterComparator',\n    value: function _greaterComparator(\n    /*object*/\n    lhs,\n    /*object*/\n    rhs)\n    /*boolean*/\n    {\n      return lhs.value > rhs.value;\n    }\n  }]);\n\n  return IntegerBufferSet;\n}();\n\nmodule.exports = IntegerBufferSet;","map":{"version":3,"sources":["C:/Versa/pagination/node_modules/fixed-data-table/internal/IntegerBufferSet.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","Heap","require","invariant","IntegerBufferSet","_valueToPositionMap","_size","_smallValues","_smallerComparator","_largeValues","_greaterComparator","getNewPositionForValue","bind","getValuePosition","getSize","replaceFurthestValuePosition","value","undefined","newPosition","_pushToHeaps","lowValue","highValue","newValue","_cleanHeaps","empty","minValue","peek","maxValue","valueToReplace","pop","position","element","push","_cleanHeap","minHeapSize","Math","min","size","maxHeapSize","max","_recreateHeaps","sourceHeap","newSmallValues","newLargeValues","heap","lhs","rhs","module","exports"],"mappings":"AAAA;;;;;;;;;;;AAYA;;AAEA,IAAIA,YAAY,GAAI,YAAY;AAAE,WAASC,gBAAT,CAA0BC,MAA1B,EAAkCC,KAAlC,EAAyC;AAAE,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,UAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,MAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,MAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,UAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,MAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAAC,SAAO,UAAUO,WAAV,EAAuBC,UAAvB,EAAmCC,WAAnC,EAAgD;AAAE,QAAID,UAAJ,EAAgBb,gBAAgB,CAACY,WAAW,CAACG,SAAb,EAAwBF,UAAxB,CAAhB;AAAqD,QAAIC,WAAJ,EAAiBd,gBAAgB,CAACY,WAAD,EAAcE,WAAd,CAAhB;AAA4C,WAAOF,WAAP;AAAqB,GAAhN;AAAmN,CAA/hB,EAAnB;;AAEA,SAASI,eAAT,CAAyBC,QAAzB,EAAmCL,WAAnC,EAAgD;AAAE,MAAI,EAAEK,QAAQ,YAAYL,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIM,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,IAAIC,IAAI,GAAGC,OAAO,CAAC,QAAD,CAAlB;;AAEA,IAAIC,SAAS,GAAGD,OAAO,CAAC,aAAD,CAAvB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAIE,gBAAgB,GAAI,YAAY;AAClC,WAASA,gBAAT,GAA4B;AAC1BN,IAAAA,eAAe,CAAC,IAAD,EAAOM,gBAAP,CAAf;;AAEA,SAAKC,mBAAL,GAA2B,EAA3B;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,YAAL,GAAoB,IAAIN,IAAJ,CAAS,EAAT,EAAa;AACjC,SAAKO,kBADe,CAApB;AAEA,SAAKC,YAAL,GAAoB,IAAIR,IAAJ,CAAS,EAAT,EAAa;AACjC,SAAKS,kBADe,CAApB;AAGA,SAAKC,sBAAL,GAA8B,KAAKA,sBAAL,CAA4BC,IAA5B,CAAiC,IAAjC,CAA9B;AACA,SAAKC,gBAAL,GAAwB,KAAKA,gBAAL,CAAsBD,IAAtB,CAA2B,IAA3B,CAAxB;AACA,SAAKE,OAAL,GAAe,KAAKA,OAAL,CAAaF,IAAb,CAAkB,IAAlB,CAAf;AACA,SAAKG,4BAAL,GAAoC,KAAKA,4BAAL,CAAkCH,IAAlC,CAAuC,IAAvC,CAApC;AACD;;AAED/B,EAAAA,YAAY,CAACuB,gBAAD,EAAmB,CAAC;AAC9BX,IAAAA,GAAG,EAAE,SADyB;AAE9BuB,IAAAA,KAAK,EAAE,SAASF,OAAT;AAAmB;AAAU;AAClC,aAAO,KAAKR,KAAZ;AACD;AAJ6B,GAAD,EAK5B;AACDb,IAAAA,GAAG,EAAE,kBADJ;AAEDuB,IAAAA,KAAK,EAAE,SAASH,gBAAT;AAA2B;AAAUG,IAAAA,KAArC;AAA4C;AAAW;AAC5D,UAAI,KAAKX,mBAAL,CAAyBW,KAAzB,MAAoCC,SAAxC,EAAmD;AACjD,eAAO,IAAP;AACD;;AACD,aAAO,KAAKZ,mBAAL,CAAyBW,KAAzB,CAAP;AACD;AAPA,GAL4B,EAa5B;AACDvB,IAAAA,GAAG,EAAE,wBADJ;AAEDuB,IAAAA,KAAK,EAAE,SAASL,sBAAT;AAAiC;AAAUK,IAAAA,KAA3C;AAAkD;AAAU;AACjEb,MAAAA,SAAS,CAAC,KAAKE,mBAAL,CAAyBW,KAAzB,MAAoCC,SAArC,EAAgD,0EAAhD,CAAT;AACA,UAAIC,WAAW,GAAG,KAAKZ,KAAvB;AACA,WAAKA,KAAL;;AACA,WAAKa,YAAL,CAAkBD,WAAlB,EAA+BF,KAA/B;;AACA,WAAKX,mBAAL,CAAyBW,KAAzB,IAAkCE,WAAlC;AACA,aAAOA,WAAP;AACD;AATA,GAb4B,EAuB5B;AACDzB,IAAAA,GAAG,EAAE,8BADJ;AAEDuB,IAAAA,KAAK,EAAE,SAASD,4BAAT;AACP;AAAUK,IAAAA,QADH;AAEP;AAAUC,IAAAA,SAFH;AAGP;AAAUC,IAAAA,QAHH;AAGa;AAAW;AAC7BnB,MAAAA,SAAS,CAAC,KAAKE,mBAAL,CAAyBiB,QAAzB,MAAuCL,SAAxC,EAAmD,wEAAwE,WAA3H,CAAT;;AAEA,WAAKM,WAAL;;AACA,UAAI,KAAKhB,YAAL,CAAkBiB,KAAlB,MAA6B,KAAKf,YAAL,CAAkBe,KAAlB,EAAjC,EAA4D;AAC1D;AACA;AACA,eAAO,IAAP;AACD;;AAED,UAAIC,QAAQ,GAAG,KAAKlB,YAAL,CAAkBmB,IAAlB,GAAyBV,KAAxC;;AACA,UAAIW,QAAQ,GAAG,KAAKlB,YAAL,CAAkBiB,IAAlB,GAAyBV,KAAxC;;AACA,UAAIS,QAAQ,IAAIL,QAAZ,IAAwBO,QAAQ,IAAIN,SAAxC,EAAmD;AACjD;AACA,eAAO,IAAP;AACD;;AAED,UAAIO,cAAJ;;AACA,UAAIR,QAAQ,GAAGK,QAAX,GAAsBE,QAAQ,GAAGN,SAArC,EAAgD;AAC9C;AACAO,QAAAA,cAAc,GAAGH,QAAjB;;AACA,aAAKlB,YAAL,CAAkBsB,GAAlB;AACD,OAJD,MAIO;AACLD,QAAAA,cAAc,GAAGD,QAAjB;;AACA,aAAKlB,YAAL,CAAkBoB,GAAlB;AACD;;AACD,UAAIC,QAAQ,GAAG,KAAKzB,mBAAL,CAAyBuB,cAAzB,CAAf;AACA,aAAO,KAAKvB,mBAAL,CAAyBuB,cAAzB,CAAP;AACA,WAAKvB,mBAAL,CAAyBiB,QAAzB,IAAqCQ,QAArC;;AACA,WAAKX,YAAL,CAAkBW,QAAlB,EAA4BR,QAA5B;;AAEA,aAAOQ,QAAP;AACD;AArCA,GAvB4B,EA6D5B;AACDrC,IAAAA,GAAG,EAAE,cADJ;AAEDuB,IAAAA,KAAK,EAAE,SAASG,YAAT;AAAuB;AAAUW,IAAAA,QAAjC;AAA2C;AAAUd,IAAAA,KAArD,EAA4D;AACjE,UAAIe,OAAO,GAAG;AACZD,QAAAA,QAAQ,EAAEA,QADE;AAEZd,QAAAA,KAAK,EAAEA;AAFK,OAAd,CADiE,CAKjE;;AACA,WAAKT,YAAL,CAAkByB,IAAlB,CAAuBD,OAAvB;;AACA,WAAKtB,YAAL,CAAkBuB,IAAlB,CAAuBD,OAAvB;AACD;AAVA,GA7D4B,EAwE5B;AACDtC,IAAAA,GAAG,EAAE,aADJ;AAEDuB,IAAAA,KAAK,EAAE,SAASO,WAAT,GAAuB;AAC5B;AACA;AACA,WAAKU,UAAL,CAAgB,KAAK1B,YAArB;;AACA,WAAK0B,UAAL,CAAgB,KAAKxB,YAArB;;AACA,UAAIyB,WAAW,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAK7B,YAAL,CAAkB8B,IAAlB,EAAT,EAAmC,KAAK5B,YAAL,CAAkB4B,IAAlB,EAAnC,CAAlB;AACA,UAAIC,WAAW,GAAGH,IAAI,CAACI,GAAL,CAAS,KAAKhC,YAAL,CAAkB8B,IAAlB,EAAT,EAAmC,KAAK5B,YAAL,CAAkB4B,IAAlB,EAAnC,CAAlB;;AACA,UAAIC,WAAW,GAAG,KAAKJ,WAAvB,EAAoC;AAClC;AACA;AACA,aAAKM,cAAL;AACD;AACF;AAdA,GAxE4B,EAuF5B;AACD/C,IAAAA,GAAG,EAAE,gBADJ;AAEDuB,IAAAA,KAAK,EAAE,SAASwB,cAAT,GAA0B;AAC/B,UAAIC,UAAU,GAAG,KAAKlC,YAAL,CAAkB8B,IAAlB,KAA2B,KAAK5B,YAAL,CAAkB4B,IAAlB,EAA3B,GAAsD,KAAK9B,YAA3D,GAA0E,KAAKE,YAAhG;AACA,UAAIiC,cAAc,GAAG,IAAIzC,IAAJ,CAAS,EAAT,EAAa;AAClC,WAAKO,kBADgB,CAArB;AAEA,UAAImC,cAAc,GAAG,IAAI1C,IAAJ,CAAS,EAAT,EAAa;AAClC,WAAKS,kBADgB,CAArB;;AAEA,aAAO,CAAC+B,UAAU,CAACjB,KAAX,EAAR,EAA4B;AAC1B,YAAIO,OAAO,GAAGU,UAAU,CAACZ,GAAX,EAAd,CAD0B,CAE1B;;AACA,YAAI,KAAKxB,mBAAL,CAAyB0B,OAAO,CAACf,KAAjC,MAA4CC,SAAhD,EAA2D;AACzDyB,UAAAA,cAAc,CAACV,IAAf,CAAoBD,OAApB;AACAY,UAAAA,cAAc,CAACX,IAAf,CAAoBD,OAApB;AACD;AACF;;AACD,WAAKxB,YAAL,GAAoBmC,cAApB;AACA,WAAKjC,YAAL,GAAoBkC,cAApB;AACD;AAlBA,GAvF4B,EA0G5B;AACDlD,IAAAA,GAAG,EAAE,YADJ;AAEDuB,IAAAA,KAAK,EAAE,SAASiB,UAAT;AAAqB;AAAUW,IAAAA,IAA/B,EAAqC;AAC1C,aAAO,CAACA,IAAI,CAACpB,KAAL,EAAD,IAAiB,KAAKnB,mBAAL,CAAyBuC,IAAI,CAAClB,IAAL,GAAYV,KAArC,MAAgDC,SAAxE,EAAmF;AACjF2B,QAAAA,IAAI,CAACf,GAAL;AACD;AACF;AANA,GA1G4B,EAiH5B;AACDpC,IAAAA,GAAG,EAAE,oBADJ;AAEDuB,IAAAA,KAAK,EAAE,SAASR,kBAAT;AAA6B;AAAUqC,IAAAA,GAAvC;AAA4C;AAAUC,IAAAA,GAAtD;AAA2D;AAAW;AAC3E,aAAOD,GAAG,CAAC7B,KAAJ,GAAY8B,GAAG,CAAC9B,KAAvB;AACD;AAJA,GAjH4B,EAsH5B;AACDvB,IAAAA,GAAG,EAAE,oBADJ;AAEDuB,IAAAA,KAAK,EAAE,SAASN,kBAAT;AAA6B;AAAUmC,IAAAA,GAAvC;AAA4C;AAAUC,IAAAA,GAAtD;AAA2D;AAAW;AAC3E,aAAOD,GAAG,CAAC7B,KAAJ,GAAY8B,GAAG,CAAC9B,KAAvB;AACD;AAJA,GAtH4B,CAAnB,CAAZ;;AA6HA,SAAOZ,gBAAP;AACD,CA/IsB,EAAvB;;AAiJA2C,MAAM,CAACC,OAAP,GAAiB5C,gBAAjB","sourcesContent":["/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule IntegerBufferSet\n * @typechecks\n */\n\n'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar Heap = require('./Heap');\n\nvar invariant = require('./invariant');\n\n// Data structure that allows to store values and assign positions to them\n// in a way to minimize changing positions of stored values when new ones are\n// added or when some values are replaced. Stored elements are alwasy assigned\n// a consecutive set of positoins startin from 0 up to count of elements less 1\n// Following actions can be executed\n// * get position assigned to given value (null if value is not stored)\n// * create new entry for new value and get assigned position back\n// * replace value that is furthest from specified value range with new value\n//   and get it's position back\n// All operations take amortized log(n) time where n is number of elements in\n// the set.\n\nvar IntegerBufferSet = (function () {\n  function IntegerBufferSet() {\n    _classCallCheck(this, IntegerBufferSet);\n\n    this._valueToPositionMap = {};\n    this._size = 0;\n    this._smallValues = new Heap([], // Initial data in the heap\n    this._smallerComparator);\n    this._largeValues = new Heap([], // Initial data in the heap\n    this._greaterComparator);\n\n    this.getNewPositionForValue = this.getNewPositionForValue.bind(this);\n    this.getValuePosition = this.getValuePosition.bind(this);\n    this.getSize = this.getSize.bind(this);\n    this.replaceFurthestValuePosition = this.replaceFurthestValuePosition.bind(this);\n  }\n\n  _createClass(IntegerBufferSet, [{\n    key: 'getSize',\n    value: function getSize() /*number*/{\n      return this._size;\n    }\n  }, {\n    key: 'getValuePosition',\n    value: function getValuePosition( /*number*/value) /*?number*/{\n      if (this._valueToPositionMap[value] === undefined) {\n        return null;\n      }\n      return this._valueToPositionMap[value];\n    }\n  }, {\n    key: 'getNewPositionForValue',\n    value: function getNewPositionForValue( /*number*/value) /*number*/{\n      invariant(this._valueToPositionMap[value] === undefined, \"Shouldn't try to find new position for value already stored in BufferSet\");\n      var newPosition = this._size;\n      this._size++;\n      this._pushToHeaps(newPosition, value);\n      this._valueToPositionMap[value] = newPosition;\n      return newPosition;\n    }\n  }, {\n    key: 'replaceFurthestValuePosition',\n    value: function replaceFurthestValuePosition(\n    /*number*/lowValue,\n    /*number*/highValue,\n    /*number*/newValue) /*?number*/{\n      invariant(this._valueToPositionMap[newValue] === undefined, \"Shouldn't try to replace values with value already stored value in \" + \"BufferSet\");\n\n      this._cleanHeaps();\n      if (this._smallValues.empty() || this._largeValues.empty()) {\n        // Threre are currently no values stored. We will have to create new\n        // position for this value.\n        return null;\n      }\n\n      var minValue = this._smallValues.peek().value;\n      var maxValue = this._largeValues.peek().value;\n      if (minValue >= lowValue && maxValue <= highValue) {\n        // All values currently stored are necessary, we can't reuse any of them.\n        return null;\n      }\n\n      var valueToReplace;\n      if (lowValue - minValue > maxValue - highValue) {\n        // minValue is further from provided range. We will reuse it's position.\n        valueToReplace = minValue;\n        this._smallValues.pop();\n      } else {\n        valueToReplace = maxValue;\n        this._largeValues.pop();\n      }\n      var position = this._valueToPositionMap[valueToReplace];\n      delete this._valueToPositionMap[valueToReplace];\n      this._valueToPositionMap[newValue] = position;\n      this._pushToHeaps(position, newValue);\n\n      return position;\n    }\n  }, {\n    key: '_pushToHeaps',\n    value: function _pushToHeaps( /*number*/position, /*number*/value) {\n      var element = {\n        position: position,\n        value: value\n      };\n      // We can reuse the same object in both heaps, because we don't mutate them\n      this._smallValues.push(element);\n      this._largeValues.push(element);\n    }\n  }, {\n    key: '_cleanHeaps',\n    value: function _cleanHeaps() {\n      // We not usually only remove object from one heap while moving value.\n      // Here we make sure that there is no stale data on top of heaps.\n      this._cleanHeap(this._smallValues);\n      this._cleanHeap(this._largeValues);\n      var minHeapSize = Math.min(this._smallValues.size(), this._largeValues.size());\n      var maxHeapSize = Math.max(this._smallValues.size(), this._largeValues.size());\n      if (maxHeapSize > 10 * minHeapSize) {\n        // There are many old values in one of heaps. We nned to get rid of them\n        // to not use too avoid memory leaks\n        this._recreateHeaps();\n      }\n    }\n  }, {\n    key: '_recreateHeaps',\n    value: function _recreateHeaps() {\n      var sourceHeap = this._smallValues.size() < this._largeValues.size() ? this._smallValues : this._largeValues;\n      var newSmallValues = new Heap([], // Initial data in the heap\n      this._smallerComparator);\n      var newLargeValues = new Heap([], // Initial datat in the heap\n      this._greaterComparator);\n      while (!sourceHeap.empty()) {\n        var element = sourceHeap.pop();\n        // Push all stil valid elements to new heaps\n        if (this._valueToPositionMap[element.value] !== undefined) {\n          newSmallValues.push(element);\n          newLargeValues.push(element);\n        }\n      }\n      this._smallValues = newSmallValues;\n      this._largeValues = newLargeValues;\n    }\n  }, {\n    key: '_cleanHeap',\n    value: function _cleanHeap( /*object*/heap) {\n      while (!heap.empty() && this._valueToPositionMap[heap.peek().value] === undefined) {\n        heap.pop();\n      }\n    }\n  }, {\n    key: '_smallerComparator',\n    value: function _smallerComparator( /*object*/lhs, /*object*/rhs) /*boolean*/{\n      return lhs.value < rhs.value;\n    }\n  }, {\n    key: '_greaterComparator',\n    value: function _greaterComparator( /*object*/lhs, /*object*/rhs) /*boolean*/{\n      return lhs.value > rhs.value;\n    }\n  }]);\n\n  return IntegerBufferSet;\n})();\n\nmodule.exports = IntegerBufferSet;"]},"metadata":{},"sourceType":"script"}